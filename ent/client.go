// Code generated by ent, DO NOT EDIT.

package ent

import (
	"context"
	"errors"
	"fmt"
	"log"
	"reflect"

	"patient/ent/migrate"

	"patient/ent/medicalhistories"
	"patient/ent/medicalprescription"
	"patient/ent/medicalsurgery"
	"patient/ent/medicaltreatment"
	"patient/ent/medication"
	"patient/ent/patient"
	"patient/ent/prescriptionmedication"

	"entgo.io/ent"
	"entgo.io/ent/dialect"
	"entgo.io/ent/dialect/sql"
	"entgo.io/ent/dialect/sql/sqlgraph"
	"github.com/google/uuid"
)

// Client is the client that holds all ent builders.
type Client struct {
	config
	// Schema is the client for creating, migrating and dropping schema.
	Schema *migrate.Schema
	// MedicalHistories is the client for interacting with the MedicalHistories builders.
	MedicalHistories *MedicalHistoriesClient
	// MedicalPrescription is the client for interacting with the MedicalPrescription builders.
	MedicalPrescription *MedicalPrescriptionClient
	// MedicalSurgery is the client for interacting with the MedicalSurgery builders.
	MedicalSurgery *MedicalSurgeryClient
	// MedicalTreatment is the client for interacting with the MedicalTreatment builders.
	MedicalTreatment *MedicalTreatmentClient
	// Medication is the client for interacting with the Medication builders.
	Medication *MedicationClient
	// Patient is the client for interacting with the Patient builders.
	Patient *PatientClient
	// PrescriptionMedication is the client for interacting with the PrescriptionMedication builders.
	PrescriptionMedication *PrescriptionMedicationClient
}

// NewClient creates a new client configured with the given options.
func NewClient(opts ...Option) *Client {
	client := &Client{config: newConfig(opts...)}
	client.init()
	return client
}

func (c *Client) init() {
	c.Schema = migrate.NewSchema(c.driver)
	c.MedicalHistories = NewMedicalHistoriesClient(c.config)
	c.MedicalPrescription = NewMedicalPrescriptionClient(c.config)
	c.MedicalSurgery = NewMedicalSurgeryClient(c.config)
	c.MedicalTreatment = NewMedicalTreatmentClient(c.config)
	c.Medication = NewMedicationClient(c.config)
	c.Patient = NewPatientClient(c.config)
	c.PrescriptionMedication = NewPrescriptionMedicationClient(c.config)
}

type (
	// config is the configuration for the client and its builder.
	config struct {
		// driver used for executing database requests.
		driver dialect.Driver
		// debug enable a debug logging.
		debug bool
		// log used for logging on debug mode.
		log func(...any)
		// hooks to execute on mutations.
		hooks *hooks
		// interceptors to execute on queries.
		inters *inters
	}
	// Option function to configure the client.
	Option func(*config)
)

// newConfig creates a new config for the client.
func newConfig(opts ...Option) config {
	cfg := config{log: log.Println, hooks: &hooks{}, inters: &inters{}}
	cfg.options(opts...)
	return cfg
}

// options applies the options on the config object.
func (c *config) options(opts ...Option) {
	for _, opt := range opts {
		opt(c)
	}
	if c.debug {
		c.driver = dialect.Debug(c.driver, c.log)
	}
}

// Debug enables debug logging on the ent.Driver.
func Debug() Option {
	return func(c *config) {
		c.debug = true
	}
}

// Log sets the logging function for debug mode.
func Log(fn func(...any)) Option {
	return func(c *config) {
		c.log = fn
	}
}

// Driver configures the client driver.
func Driver(driver dialect.Driver) Option {
	return func(c *config) {
		c.driver = driver
	}
}

// Open opens a database/sql.DB specified by the driver name and
// the data source name, and returns a new client attached to it.
// Optional parameters can be added for configuring the client.
func Open(driverName, dataSourceName string, options ...Option) (*Client, error) {
	switch driverName {
	case dialect.MySQL, dialect.Postgres, dialect.SQLite:
		drv, err := sql.Open(driverName, dataSourceName)
		if err != nil {
			return nil, err
		}
		return NewClient(append(options, Driver(drv))...), nil
	default:
		return nil, fmt.Errorf("unsupported driver: %q", driverName)
	}
}

// ErrTxStarted is returned when trying to start a new transaction from a transactional client.
var ErrTxStarted = errors.New("ent: cannot start a transaction within a transaction")

// Tx returns a new transactional client. The provided context
// is used until the transaction is committed or rolled back.
func (c *Client) Tx(ctx context.Context) (*Tx, error) {
	if _, ok := c.driver.(*txDriver); ok {
		return nil, ErrTxStarted
	}
	tx, err := newTx(ctx, c.driver)
	if err != nil {
		return nil, fmt.Errorf("ent: starting a transaction: %w", err)
	}
	cfg := c.config
	cfg.driver = tx
	return &Tx{
		ctx:                    ctx,
		config:                 cfg,
		MedicalHistories:       NewMedicalHistoriesClient(cfg),
		MedicalPrescription:    NewMedicalPrescriptionClient(cfg),
		MedicalSurgery:         NewMedicalSurgeryClient(cfg),
		MedicalTreatment:       NewMedicalTreatmentClient(cfg),
		Medication:             NewMedicationClient(cfg),
		Patient:                NewPatientClient(cfg),
		PrescriptionMedication: NewPrescriptionMedicationClient(cfg),
	}, nil
}

// BeginTx returns a transactional client with specified options.
func (c *Client) BeginTx(ctx context.Context, opts *sql.TxOptions) (*Tx, error) {
	if _, ok := c.driver.(*txDriver); ok {
		return nil, errors.New("ent: cannot start a transaction within a transaction")
	}
	tx, err := c.driver.(interface {
		BeginTx(context.Context, *sql.TxOptions) (dialect.Tx, error)
	}).BeginTx(ctx, opts)
	if err != nil {
		return nil, fmt.Errorf("ent: starting a transaction: %w", err)
	}
	cfg := c.config
	cfg.driver = &txDriver{tx: tx, drv: c.driver}
	return &Tx{
		ctx:                    ctx,
		config:                 cfg,
		MedicalHistories:       NewMedicalHistoriesClient(cfg),
		MedicalPrescription:    NewMedicalPrescriptionClient(cfg),
		MedicalSurgery:         NewMedicalSurgeryClient(cfg),
		MedicalTreatment:       NewMedicalTreatmentClient(cfg),
		Medication:             NewMedicationClient(cfg),
		Patient:                NewPatientClient(cfg),
		PrescriptionMedication: NewPrescriptionMedicationClient(cfg),
	}, nil
}

// Debug returns a new debug-client. It's used to get verbose logging on specific operations.
//
//	client.Debug().
//		MedicalHistories.
//		Query().
//		Count(ctx)
func (c *Client) Debug() *Client {
	if c.debug {
		return c
	}
	cfg := c.config
	cfg.driver = dialect.Debug(c.driver, c.log)
	client := &Client{config: cfg}
	client.init()
	return client
}

// Close closes the database connection and prevents new queries from starting.
func (c *Client) Close() error {
	return c.driver.Close()
}

// Use adds the mutation hooks to all the entity clients.
// In order to add hooks to a specific client, call: `client.Node.Use(...)`.
func (c *Client) Use(hooks ...Hook) {
	for _, n := range []interface{ Use(...Hook) }{
		c.MedicalHistories, c.MedicalPrescription, c.MedicalSurgery, c.MedicalTreatment,
		c.Medication, c.Patient, c.PrescriptionMedication,
	} {
		n.Use(hooks...)
	}
}

// Intercept adds the query interceptors to all the entity clients.
// In order to add interceptors to a specific client, call: `client.Node.Intercept(...)`.
func (c *Client) Intercept(interceptors ...Interceptor) {
	for _, n := range []interface{ Intercept(...Interceptor) }{
		c.MedicalHistories, c.MedicalPrescription, c.MedicalSurgery, c.MedicalTreatment,
		c.Medication, c.Patient, c.PrescriptionMedication,
	} {
		n.Intercept(interceptors...)
	}
}

// Mutate implements the ent.Mutator interface.
func (c *Client) Mutate(ctx context.Context, m Mutation) (Value, error) {
	switch m := m.(type) {
	case *MedicalHistoriesMutation:
		return c.MedicalHistories.mutate(ctx, m)
	case *MedicalPrescriptionMutation:
		return c.MedicalPrescription.mutate(ctx, m)
	case *MedicalSurgeryMutation:
		return c.MedicalSurgery.mutate(ctx, m)
	case *MedicalTreatmentMutation:
		return c.MedicalTreatment.mutate(ctx, m)
	case *MedicationMutation:
		return c.Medication.mutate(ctx, m)
	case *PatientMutation:
		return c.Patient.mutate(ctx, m)
	case *PrescriptionMedicationMutation:
		return c.PrescriptionMedication.mutate(ctx, m)
	default:
		return nil, fmt.Errorf("ent: unknown mutation type %T", m)
	}
}

// MedicalHistoriesClient is a client for the MedicalHistories schema.
type MedicalHistoriesClient struct {
	config
}

// NewMedicalHistoriesClient returns a client for the MedicalHistories from the given config.
func NewMedicalHistoriesClient(c config) *MedicalHistoriesClient {
	return &MedicalHistoriesClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `medicalhistories.Hooks(f(g(h())))`.
func (c *MedicalHistoriesClient) Use(hooks ...Hook) {
	c.hooks.MedicalHistories = append(c.hooks.MedicalHistories, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `medicalhistories.Intercept(f(g(h())))`.
func (c *MedicalHistoriesClient) Intercept(interceptors ...Interceptor) {
	c.inters.MedicalHistories = append(c.inters.MedicalHistories, interceptors...)
}

// Create returns a builder for creating a MedicalHistories entity.
func (c *MedicalHistoriesClient) Create() *MedicalHistoriesCreate {
	mutation := newMedicalHistoriesMutation(c.config, OpCreate)
	return &MedicalHistoriesCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of MedicalHistories entities.
func (c *MedicalHistoriesClient) CreateBulk(builders ...*MedicalHistoriesCreate) *MedicalHistoriesCreateBulk {
	return &MedicalHistoriesCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *MedicalHistoriesClient) MapCreateBulk(slice any, setFunc func(*MedicalHistoriesCreate, int)) *MedicalHistoriesCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &MedicalHistoriesCreateBulk{err: fmt.Errorf("calling to MedicalHistoriesClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*MedicalHistoriesCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &MedicalHistoriesCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for MedicalHistories.
func (c *MedicalHistoriesClient) Update() *MedicalHistoriesUpdate {
	mutation := newMedicalHistoriesMutation(c.config, OpUpdate)
	return &MedicalHistoriesUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *MedicalHistoriesClient) UpdateOne(mh *MedicalHistories) *MedicalHistoriesUpdateOne {
	mutation := newMedicalHistoriesMutation(c.config, OpUpdateOne, withMedicalHistories(mh))
	return &MedicalHistoriesUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *MedicalHistoriesClient) UpdateOneID(id uuid.UUID) *MedicalHistoriesUpdateOne {
	mutation := newMedicalHistoriesMutation(c.config, OpUpdateOne, withMedicalHistoriesID(id))
	return &MedicalHistoriesUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for MedicalHistories.
func (c *MedicalHistoriesClient) Delete() *MedicalHistoriesDelete {
	mutation := newMedicalHistoriesMutation(c.config, OpDelete)
	return &MedicalHistoriesDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *MedicalHistoriesClient) DeleteOne(mh *MedicalHistories) *MedicalHistoriesDeleteOne {
	return c.DeleteOneID(mh.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *MedicalHistoriesClient) DeleteOneID(id uuid.UUID) *MedicalHistoriesDeleteOne {
	builder := c.Delete().Where(medicalhistories.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &MedicalHistoriesDeleteOne{builder}
}

// Query returns a query builder for MedicalHistories.
func (c *MedicalHistoriesClient) Query() *MedicalHistoriesQuery {
	return &MedicalHistoriesQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeMedicalHistories},
		inters: c.Interceptors(),
	}
}

// Get returns a MedicalHistories entity by its id.
func (c *MedicalHistoriesClient) Get(ctx context.Context, id uuid.UUID) (*MedicalHistories, error) {
	return c.Query().Where(medicalhistories.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *MedicalHistoriesClient) GetX(ctx context.Context, id uuid.UUID) *MedicalHistories {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryPatient queries the patient edge of a MedicalHistories.
func (c *MedicalHistoriesClient) QueryPatient(mh *MedicalHistories) *PatientQuery {
	query := (&PatientClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := mh.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(medicalhistories.Table, medicalhistories.FieldID, id),
			sqlgraph.To(patient.Table, patient.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, medicalhistories.PatientTable, medicalhistories.PatientColumn),
		)
		fromV = sqlgraph.Neighbors(mh.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryMedicalPrescription queries the medical_prescription edge of a MedicalHistories.
func (c *MedicalHistoriesClient) QueryMedicalPrescription(mh *MedicalHistories) *MedicalPrescriptionQuery {
	query := (&MedicalPrescriptionClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := mh.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(medicalhistories.Table, medicalhistories.FieldID, id),
			sqlgraph.To(medicalprescription.Table, medicalprescription.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, medicalhistories.MedicalPrescriptionTable, medicalhistories.MedicalPrescriptionColumn),
		)
		fromV = sqlgraph.Neighbors(mh.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryMedicalTreatment queries the medical_treatment edge of a MedicalHistories.
func (c *MedicalHistoriesClient) QueryMedicalTreatment(mh *MedicalHistories) *MedicalTreatmentQuery {
	query := (&MedicalTreatmentClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := mh.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(medicalhistories.Table, medicalhistories.FieldID, id),
			sqlgraph.To(medicaltreatment.Table, medicaltreatment.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, medicalhistories.MedicalTreatmentTable, medicalhistories.MedicalTreatmentColumn),
		)
		fromV = sqlgraph.Neighbors(mh.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryMedicalSurgery queries the medical_surgery edge of a MedicalHistories.
func (c *MedicalHistoriesClient) QueryMedicalSurgery(mh *MedicalHistories) *MedicalSurgeryQuery {
	query := (&MedicalSurgeryClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := mh.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(medicalhistories.Table, medicalhistories.FieldID, id),
			sqlgraph.To(medicalsurgery.Table, medicalsurgery.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, medicalhistories.MedicalSurgeryTable, medicalhistories.MedicalSurgeryColumn),
		)
		fromV = sqlgraph.Neighbors(mh.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *MedicalHistoriesClient) Hooks() []Hook {
	return c.hooks.MedicalHistories
}

// Interceptors returns the client interceptors.
func (c *MedicalHistoriesClient) Interceptors() []Interceptor {
	return c.inters.MedicalHistories
}

func (c *MedicalHistoriesClient) mutate(ctx context.Context, m *MedicalHistoriesMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&MedicalHistoriesCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&MedicalHistoriesUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&MedicalHistoriesUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&MedicalHistoriesDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown MedicalHistories mutation op: %q", m.Op())
	}
}

// MedicalPrescriptionClient is a client for the MedicalPrescription schema.
type MedicalPrescriptionClient struct {
	config
}

// NewMedicalPrescriptionClient returns a client for the MedicalPrescription from the given config.
func NewMedicalPrescriptionClient(c config) *MedicalPrescriptionClient {
	return &MedicalPrescriptionClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `medicalprescription.Hooks(f(g(h())))`.
func (c *MedicalPrescriptionClient) Use(hooks ...Hook) {
	c.hooks.MedicalPrescription = append(c.hooks.MedicalPrescription, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `medicalprescription.Intercept(f(g(h())))`.
func (c *MedicalPrescriptionClient) Intercept(interceptors ...Interceptor) {
	c.inters.MedicalPrescription = append(c.inters.MedicalPrescription, interceptors...)
}

// Create returns a builder for creating a MedicalPrescription entity.
func (c *MedicalPrescriptionClient) Create() *MedicalPrescriptionCreate {
	mutation := newMedicalPrescriptionMutation(c.config, OpCreate)
	return &MedicalPrescriptionCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of MedicalPrescription entities.
func (c *MedicalPrescriptionClient) CreateBulk(builders ...*MedicalPrescriptionCreate) *MedicalPrescriptionCreateBulk {
	return &MedicalPrescriptionCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *MedicalPrescriptionClient) MapCreateBulk(slice any, setFunc func(*MedicalPrescriptionCreate, int)) *MedicalPrescriptionCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &MedicalPrescriptionCreateBulk{err: fmt.Errorf("calling to MedicalPrescriptionClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*MedicalPrescriptionCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &MedicalPrescriptionCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for MedicalPrescription.
func (c *MedicalPrescriptionClient) Update() *MedicalPrescriptionUpdate {
	mutation := newMedicalPrescriptionMutation(c.config, OpUpdate)
	return &MedicalPrescriptionUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *MedicalPrescriptionClient) UpdateOne(mp *MedicalPrescription) *MedicalPrescriptionUpdateOne {
	mutation := newMedicalPrescriptionMutation(c.config, OpUpdateOne, withMedicalPrescription(mp))
	return &MedicalPrescriptionUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *MedicalPrescriptionClient) UpdateOneID(id uuid.UUID) *MedicalPrescriptionUpdateOne {
	mutation := newMedicalPrescriptionMutation(c.config, OpUpdateOne, withMedicalPrescriptionID(id))
	return &MedicalPrescriptionUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for MedicalPrescription.
func (c *MedicalPrescriptionClient) Delete() *MedicalPrescriptionDelete {
	mutation := newMedicalPrescriptionMutation(c.config, OpDelete)
	return &MedicalPrescriptionDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *MedicalPrescriptionClient) DeleteOne(mp *MedicalPrescription) *MedicalPrescriptionDeleteOne {
	return c.DeleteOneID(mp.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *MedicalPrescriptionClient) DeleteOneID(id uuid.UUID) *MedicalPrescriptionDeleteOne {
	builder := c.Delete().Where(medicalprescription.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &MedicalPrescriptionDeleteOne{builder}
}

// Query returns a query builder for MedicalPrescription.
func (c *MedicalPrescriptionClient) Query() *MedicalPrescriptionQuery {
	return &MedicalPrescriptionQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeMedicalPrescription},
		inters: c.Interceptors(),
	}
}

// Get returns a MedicalPrescription entity by its id.
func (c *MedicalPrescriptionClient) Get(ctx context.Context, id uuid.UUID) (*MedicalPrescription, error) {
	return c.Query().Where(medicalprescription.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *MedicalPrescriptionClient) GetX(ctx context.Context, id uuid.UUID) *MedicalPrescription {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryMedicalHistories queries the medical_histories edge of a MedicalPrescription.
func (c *MedicalPrescriptionClient) QueryMedicalHistories(mp *MedicalPrescription) *MedicalHistoriesQuery {
	query := (&MedicalHistoriesClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := mp.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(medicalprescription.Table, medicalprescription.FieldID, id),
			sqlgraph.To(medicalhistories.Table, medicalhistories.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, medicalprescription.MedicalHistoriesTable, medicalprescription.MedicalHistoriesColumn),
		)
		fromV = sqlgraph.Neighbors(mp.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryPrescriptionMedication queries the prescription_medication edge of a MedicalPrescription.
func (c *MedicalPrescriptionClient) QueryPrescriptionMedication(mp *MedicalPrescription) *PrescriptionMedicationQuery {
	query := (&PrescriptionMedicationClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := mp.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(medicalprescription.Table, medicalprescription.FieldID, id),
			sqlgraph.To(prescriptionmedication.Table, prescriptionmedication.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, medicalprescription.PrescriptionMedicationTable, medicalprescription.PrescriptionMedicationColumn),
		)
		fromV = sqlgraph.Neighbors(mp.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *MedicalPrescriptionClient) Hooks() []Hook {
	return c.hooks.MedicalPrescription
}

// Interceptors returns the client interceptors.
func (c *MedicalPrescriptionClient) Interceptors() []Interceptor {
	return c.inters.MedicalPrescription
}

func (c *MedicalPrescriptionClient) mutate(ctx context.Context, m *MedicalPrescriptionMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&MedicalPrescriptionCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&MedicalPrescriptionUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&MedicalPrescriptionUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&MedicalPrescriptionDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown MedicalPrescription mutation op: %q", m.Op())
	}
}

// MedicalSurgeryClient is a client for the MedicalSurgery schema.
type MedicalSurgeryClient struct {
	config
}

// NewMedicalSurgeryClient returns a client for the MedicalSurgery from the given config.
func NewMedicalSurgeryClient(c config) *MedicalSurgeryClient {
	return &MedicalSurgeryClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `medicalsurgery.Hooks(f(g(h())))`.
func (c *MedicalSurgeryClient) Use(hooks ...Hook) {
	c.hooks.MedicalSurgery = append(c.hooks.MedicalSurgery, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `medicalsurgery.Intercept(f(g(h())))`.
func (c *MedicalSurgeryClient) Intercept(interceptors ...Interceptor) {
	c.inters.MedicalSurgery = append(c.inters.MedicalSurgery, interceptors...)
}

// Create returns a builder for creating a MedicalSurgery entity.
func (c *MedicalSurgeryClient) Create() *MedicalSurgeryCreate {
	mutation := newMedicalSurgeryMutation(c.config, OpCreate)
	return &MedicalSurgeryCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of MedicalSurgery entities.
func (c *MedicalSurgeryClient) CreateBulk(builders ...*MedicalSurgeryCreate) *MedicalSurgeryCreateBulk {
	return &MedicalSurgeryCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *MedicalSurgeryClient) MapCreateBulk(slice any, setFunc func(*MedicalSurgeryCreate, int)) *MedicalSurgeryCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &MedicalSurgeryCreateBulk{err: fmt.Errorf("calling to MedicalSurgeryClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*MedicalSurgeryCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &MedicalSurgeryCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for MedicalSurgery.
func (c *MedicalSurgeryClient) Update() *MedicalSurgeryUpdate {
	mutation := newMedicalSurgeryMutation(c.config, OpUpdate)
	return &MedicalSurgeryUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *MedicalSurgeryClient) UpdateOne(ms *MedicalSurgery) *MedicalSurgeryUpdateOne {
	mutation := newMedicalSurgeryMutation(c.config, OpUpdateOne, withMedicalSurgery(ms))
	return &MedicalSurgeryUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *MedicalSurgeryClient) UpdateOneID(id uuid.UUID) *MedicalSurgeryUpdateOne {
	mutation := newMedicalSurgeryMutation(c.config, OpUpdateOne, withMedicalSurgeryID(id))
	return &MedicalSurgeryUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for MedicalSurgery.
func (c *MedicalSurgeryClient) Delete() *MedicalSurgeryDelete {
	mutation := newMedicalSurgeryMutation(c.config, OpDelete)
	return &MedicalSurgeryDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *MedicalSurgeryClient) DeleteOne(ms *MedicalSurgery) *MedicalSurgeryDeleteOne {
	return c.DeleteOneID(ms.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *MedicalSurgeryClient) DeleteOneID(id uuid.UUID) *MedicalSurgeryDeleteOne {
	builder := c.Delete().Where(medicalsurgery.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &MedicalSurgeryDeleteOne{builder}
}

// Query returns a query builder for MedicalSurgery.
func (c *MedicalSurgeryClient) Query() *MedicalSurgeryQuery {
	return &MedicalSurgeryQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeMedicalSurgery},
		inters: c.Interceptors(),
	}
}

// Get returns a MedicalSurgery entity by its id.
func (c *MedicalSurgeryClient) Get(ctx context.Context, id uuid.UUID) (*MedicalSurgery, error) {
	return c.Query().Where(medicalsurgery.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *MedicalSurgeryClient) GetX(ctx context.Context, id uuid.UUID) *MedicalSurgery {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryMedicalHistories queries the medical_histories edge of a MedicalSurgery.
func (c *MedicalSurgeryClient) QueryMedicalHistories(ms *MedicalSurgery) *MedicalHistoriesQuery {
	query := (&MedicalHistoriesClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := ms.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(medicalsurgery.Table, medicalsurgery.FieldID, id),
			sqlgraph.To(medicalhistories.Table, medicalhistories.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, medicalsurgery.MedicalHistoriesTable, medicalsurgery.MedicalHistoriesColumn),
		)
		fromV = sqlgraph.Neighbors(ms.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *MedicalSurgeryClient) Hooks() []Hook {
	return c.hooks.MedicalSurgery
}

// Interceptors returns the client interceptors.
func (c *MedicalSurgeryClient) Interceptors() []Interceptor {
	return c.inters.MedicalSurgery
}

func (c *MedicalSurgeryClient) mutate(ctx context.Context, m *MedicalSurgeryMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&MedicalSurgeryCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&MedicalSurgeryUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&MedicalSurgeryUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&MedicalSurgeryDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown MedicalSurgery mutation op: %q", m.Op())
	}
}

// MedicalTreatmentClient is a client for the MedicalTreatment schema.
type MedicalTreatmentClient struct {
	config
}

// NewMedicalTreatmentClient returns a client for the MedicalTreatment from the given config.
func NewMedicalTreatmentClient(c config) *MedicalTreatmentClient {
	return &MedicalTreatmentClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `medicaltreatment.Hooks(f(g(h())))`.
func (c *MedicalTreatmentClient) Use(hooks ...Hook) {
	c.hooks.MedicalTreatment = append(c.hooks.MedicalTreatment, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `medicaltreatment.Intercept(f(g(h())))`.
func (c *MedicalTreatmentClient) Intercept(interceptors ...Interceptor) {
	c.inters.MedicalTreatment = append(c.inters.MedicalTreatment, interceptors...)
}

// Create returns a builder for creating a MedicalTreatment entity.
func (c *MedicalTreatmentClient) Create() *MedicalTreatmentCreate {
	mutation := newMedicalTreatmentMutation(c.config, OpCreate)
	return &MedicalTreatmentCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of MedicalTreatment entities.
func (c *MedicalTreatmentClient) CreateBulk(builders ...*MedicalTreatmentCreate) *MedicalTreatmentCreateBulk {
	return &MedicalTreatmentCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *MedicalTreatmentClient) MapCreateBulk(slice any, setFunc func(*MedicalTreatmentCreate, int)) *MedicalTreatmentCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &MedicalTreatmentCreateBulk{err: fmt.Errorf("calling to MedicalTreatmentClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*MedicalTreatmentCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &MedicalTreatmentCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for MedicalTreatment.
func (c *MedicalTreatmentClient) Update() *MedicalTreatmentUpdate {
	mutation := newMedicalTreatmentMutation(c.config, OpUpdate)
	return &MedicalTreatmentUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *MedicalTreatmentClient) UpdateOne(mt *MedicalTreatment) *MedicalTreatmentUpdateOne {
	mutation := newMedicalTreatmentMutation(c.config, OpUpdateOne, withMedicalTreatment(mt))
	return &MedicalTreatmentUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *MedicalTreatmentClient) UpdateOneID(id uuid.UUID) *MedicalTreatmentUpdateOne {
	mutation := newMedicalTreatmentMutation(c.config, OpUpdateOne, withMedicalTreatmentID(id))
	return &MedicalTreatmentUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for MedicalTreatment.
func (c *MedicalTreatmentClient) Delete() *MedicalTreatmentDelete {
	mutation := newMedicalTreatmentMutation(c.config, OpDelete)
	return &MedicalTreatmentDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *MedicalTreatmentClient) DeleteOne(mt *MedicalTreatment) *MedicalTreatmentDeleteOne {
	return c.DeleteOneID(mt.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *MedicalTreatmentClient) DeleteOneID(id uuid.UUID) *MedicalTreatmentDeleteOne {
	builder := c.Delete().Where(medicaltreatment.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &MedicalTreatmentDeleteOne{builder}
}

// Query returns a query builder for MedicalTreatment.
func (c *MedicalTreatmentClient) Query() *MedicalTreatmentQuery {
	return &MedicalTreatmentQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeMedicalTreatment},
		inters: c.Interceptors(),
	}
}

// Get returns a MedicalTreatment entity by its id.
func (c *MedicalTreatmentClient) Get(ctx context.Context, id uuid.UUID) (*MedicalTreatment, error) {
	return c.Query().Where(medicaltreatment.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *MedicalTreatmentClient) GetX(ctx context.Context, id uuid.UUID) *MedicalTreatment {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryMedicalHistories queries the medical_histories edge of a MedicalTreatment.
func (c *MedicalTreatmentClient) QueryMedicalHistories(mt *MedicalTreatment) *MedicalHistoriesQuery {
	query := (&MedicalHistoriesClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := mt.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(medicaltreatment.Table, medicaltreatment.FieldID, id),
			sqlgraph.To(medicalhistories.Table, medicalhistories.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, medicaltreatment.MedicalHistoriesTable, medicaltreatment.MedicalHistoriesColumn),
		)
		fromV = sqlgraph.Neighbors(mt.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *MedicalTreatmentClient) Hooks() []Hook {
	return c.hooks.MedicalTreatment
}

// Interceptors returns the client interceptors.
func (c *MedicalTreatmentClient) Interceptors() []Interceptor {
	return c.inters.MedicalTreatment
}

func (c *MedicalTreatmentClient) mutate(ctx context.Context, m *MedicalTreatmentMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&MedicalTreatmentCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&MedicalTreatmentUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&MedicalTreatmentUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&MedicalTreatmentDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown MedicalTreatment mutation op: %q", m.Op())
	}
}

// MedicationClient is a client for the Medication schema.
type MedicationClient struct {
	config
}

// NewMedicationClient returns a client for the Medication from the given config.
func NewMedicationClient(c config) *MedicationClient {
	return &MedicationClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `medication.Hooks(f(g(h())))`.
func (c *MedicationClient) Use(hooks ...Hook) {
	c.hooks.Medication = append(c.hooks.Medication, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `medication.Intercept(f(g(h())))`.
func (c *MedicationClient) Intercept(interceptors ...Interceptor) {
	c.inters.Medication = append(c.inters.Medication, interceptors...)
}

// Create returns a builder for creating a Medication entity.
func (c *MedicationClient) Create() *MedicationCreate {
	mutation := newMedicationMutation(c.config, OpCreate)
	return &MedicationCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Medication entities.
func (c *MedicationClient) CreateBulk(builders ...*MedicationCreate) *MedicationCreateBulk {
	return &MedicationCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *MedicationClient) MapCreateBulk(slice any, setFunc func(*MedicationCreate, int)) *MedicationCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &MedicationCreateBulk{err: fmt.Errorf("calling to MedicationClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*MedicationCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &MedicationCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Medication.
func (c *MedicationClient) Update() *MedicationUpdate {
	mutation := newMedicationMutation(c.config, OpUpdate)
	return &MedicationUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *MedicationClient) UpdateOne(m *Medication) *MedicationUpdateOne {
	mutation := newMedicationMutation(c.config, OpUpdateOne, withMedication(m))
	return &MedicationUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *MedicationClient) UpdateOneID(id uuid.UUID) *MedicationUpdateOne {
	mutation := newMedicationMutation(c.config, OpUpdateOne, withMedicationID(id))
	return &MedicationUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Medication.
func (c *MedicationClient) Delete() *MedicationDelete {
	mutation := newMedicationMutation(c.config, OpDelete)
	return &MedicationDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *MedicationClient) DeleteOne(m *Medication) *MedicationDeleteOne {
	return c.DeleteOneID(m.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *MedicationClient) DeleteOneID(id uuid.UUID) *MedicationDeleteOne {
	builder := c.Delete().Where(medication.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &MedicationDeleteOne{builder}
}

// Query returns a query builder for Medication.
func (c *MedicationClient) Query() *MedicationQuery {
	return &MedicationQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeMedication},
		inters: c.Interceptors(),
	}
}

// Get returns a Medication entity by its id.
func (c *MedicationClient) Get(ctx context.Context, id uuid.UUID) (*Medication, error) {
	return c.Query().Where(medication.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *MedicationClient) GetX(ctx context.Context, id uuid.UUID) *Medication {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryPrescriptionMedication queries the prescription_medication edge of a Medication.
func (c *MedicationClient) QueryPrescriptionMedication(m *Medication) *PrescriptionMedicationQuery {
	query := (&PrescriptionMedicationClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(medication.Table, medication.FieldID, id),
			sqlgraph.To(prescriptionmedication.Table, prescriptionmedication.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, medication.PrescriptionMedicationTable, medication.PrescriptionMedicationColumn),
		)
		fromV = sqlgraph.Neighbors(m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *MedicationClient) Hooks() []Hook {
	return c.hooks.Medication
}

// Interceptors returns the client interceptors.
func (c *MedicationClient) Interceptors() []Interceptor {
	return c.inters.Medication
}

func (c *MedicationClient) mutate(ctx context.Context, m *MedicationMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&MedicationCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&MedicationUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&MedicationUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&MedicationDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown Medication mutation op: %q", m.Op())
	}
}

// PatientClient is a client for the Patient schema.
type PatientClient struct {
	config
}

// NewPatientClient returns a client for the Patient from the given config.
func NewPatientClient(c config) *PatientClient {
	return &PatientClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `patient.Hooks(f(g(h())))`.
func (c *PatientClient) Use(hooks ...Hook) {
	c.hooks.Patient = append(c.hooks.Patient, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `patient.Intercept(f(g(h())))`.
func (c *PatientClient) Intercept(interceptors ...Interceptor) {
	c.inters.Patient = append(c.inters.Patient, interceptors...)
}

// Create returns a builder for creating a Patient entity.
func (c *PatientClient) Create() *PatientCreate {
	mutation := newPatientMutation(c.config, OpCreate)
	return &PatientCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Patient entities.
func (c *PatientClient) CreateBulk(builders ...*PatientCreate) *PatientCreateBulk {
	return &PatientCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *PatientClient) MapCreateBulk(slice any, setFunc func(*PatientCreate, int)) *PatientCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &PatientCreateBulk{err: fmt.Errorf("calling to PatientClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*PatientCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &PatientCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Patient.
func (c *PatientClient) Update() *PatientUpdate {
	mutation := newPatientMutation(c.config, OpUpdate)
	return &PatientUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *PatientClient) UpdateOne(pa *Patient) *PatientUpdateOne {
	mutation := newPatientMutation(c.config, OpUpdateOne, withPatient(pa))
	return &PatientUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *PatientClient) UpdateOneID(id uuid.UUID) *PatientUpdateOne {
	mutation := newPatientMutation(c.config, OpUpdateOne, withPatientID(id))
	return &PatientUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Patient.
func (c *PatientClient) Delete() *PatientDelete {
	mutation := newPatientMutation(c.config, OpDelete)
	return &PatientDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *PatientClient) DeleteOne(pa *Patient) *PatientDeleteOne {
	return c.DeleteOneID(pa.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *PatientClient) DeleteOneID(id uuid.UUID) *PatientDeleteOne {
	builder := c.Delete().Where(patient.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &PatientDeleteOne{builder}
}

// Query returns a query builder for Patient.
func (c *PatientClient) Query() *PatientQuery {
	return &PatientQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypePatient},
		inters: c.Interceptors(),
	}
}

// Get returns a Patient entity by its id.
func (c *PatientClient) Get(ctx context.Context, id uuid.UUID) (*Patient, error) {
	return c.Query().Where(patient.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *PatientClient) GetX(ctx context.Context, id uuid.UUID) *Patient {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryMedicalHistory queries the medical_history edge of a Patient.
func (c *PatientClient) QueryMedicalHistory(pa *Patient) *MedicalHistoriesQuery {
	query := (&MedicalHistoriesClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := pa.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(patient.Table, patient.FieldID, id),
			sqlgraph.To(medicalhistories.Table, medicalhistories.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, patient.MedicalHistoryTable, patient.MedicalHistoryColumn),
		)
		fromV = sqlgraph.Neighbors(pa.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *PatientClient) Hooks() []Hook {
	return c.hooks.Patient
}

// Interceptors returns the client interceptors.
func (c *PatientClient) Interceptors() []Interceptor {
	return c.inters.Patient
}

func (c *PatientClient) mutate(ctx context.Context, m *PatientMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&PatientCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&PatientUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&PatientUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&PatientDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown Patient mutation op: %q", m.Op())
	}
}

// PrescriptionMedicationClient is a client for the PrescriptionMedication schema.
type PrescriptionMedicationClient struct {
	config
}

// NewPrescriptionMedicationClient returns a client for the PrescriptionMedication from the given config.
func NewPrescriptionMedicationClient(c config) *PrescriptionMedicationClient {
	return &PrescriptionMedicationClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `prescriptionmedication.Hooks(f(g(h())))`.
func (c *PrescriptionMedicationClient) Use(hooks ...Hook) {
	c.hooks.PrescriptionMedication = append(c.hooks.PrescriptionMedication, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `prescriptionmedication.Intercept(f(g(h())))`.
func (c *PrescriptionMedicationClient) Intercept(interceptors ...Interceptor) {
	c.inters.PrescriptionMedication = append(c.inters.PrescriptionMedication, interceptors...)
}

// Create returns a builder for creating a PrescriptionMedication entity.
func (c *PrescriptionMedicationClient) Create() *PrescriptionMedicationCreate {
	mutation := newPrescriptionMedicationMutation(c.config, OpCreate)
	return &PrescriptionMedicationCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of PrescriptionMedication entities.
func (c *PrescriptionMedicationClient) CreateBulk(builders ...*PrescriptionMedicationCreate) *PrescriptionMedicationCreateBulk {
	return &PrescriptionMedicationCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *PrescriptionMedicationClient) MapCreateBulk(slice any, setFunc func(*PrescriptionMedicationCreate, int)) *PrescriptionMedicationCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &PrescriptionMedicationCreateBulk{err: fmt.Errorf("calling to PrescriptionMedicationClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*PrescriptionMedicationCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &PrescriptionMedicationCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for PrescriptionMedication.
func (c *PrescriptionMedicationClient) Update() *PrescriptionMedicationUpdate {
	mutation := newPrescriptionMedicationMutation(c.config, OpUpdate)
	return &PrescriptionMedicationUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *PrescriptionMedicationClient) UpdateOne(pm *PrescriptionMedication) *PrescriptionMedicationUpdateOne {
	mutation := newPrescriptionMedicationMutation(c.config, OpUpdateOne, withPrescriptionMedication(pm))
	return &PrescriptionMedicationUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *PrescriptionMedicationClient) UpdateOneID(id uuid.UUID) *PrescriptionMedicationUpdateOne {
	mutation := newPrescriptionMedicationMutation(c.config, OpUpdateOne, withPrescriptionMedicationID(id))
	return &PrescriptionMedicationUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for PrescriptionMedication.
func (c *PrescriptionMedicationClient) Delete() *PrescriptionMedicationDelete {
	mutation := newPrescriptionMedicationMutation(c.config, OpDelete)
	return &PrescriptionMedicationDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *PrescriptionMedicationClient) DeleteOne(pm *PrescriptionMedication) *PrescriptionMedicationDeleteOne {
	return c.DeleteOneID(pm.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *PrescriptionMedicationClient) DeleteOneID(id uuid.UUID) *PrescriptionMedicationDeleteOne {
	builder := c.Delete().Where(prescriptionmedication.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &PrescriptionMedicationDeleteOne{builder}
}

// Query returns a query builder for PrescriptionMedication.
func (c *PrescriptionMedicationClient) Query() *PrescriptionMedicationQuery {
	return &PrescriptionMedicationQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypePrescriptionMedication},
		inters: c.Interceptors(),
	}
}

// Get returns a PrescriptionMedication entity by its id.
func (c *PrescriptionMedicationClient) Get(ctx context.Context, id uuid.UUID) (*PrescriptionMedication, error) {
	return c.Query().Where(prescriptionmedication.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *PrescriptionMedicationClient) GetX(ctx context.Context, id uuid.UUID) *PrescriptionMedication {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryMedicalPrescription queries the medical_prescription edge of a PrescriptionMedication.
func (c *PrescriptionMedicationClient) QueryMedicalPrescription(pm *PrescriptionMedication) *MedicalPrescriptionQuery {
	query := (&MedicalPrescriptionClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := pm.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(prescriptionmedication.Table, prescriptionmedication.FieldID, id),
			sqlgraph.To(medicalprescription.Table, medicalprescription.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, prescriptionmedication.MedicalPrescriptionTable, prescriptionmedication.MedicalPrescriptionColumn),
		)
		fromV = sqlgraph.Neighbors(pm.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryMedication queries the medication edge of a PrescriptionMedication.
func (c *PrescriptionMedicationClient) QueryMedication(pm *PrescriptionMedication) *MedicationQuery {
	query := (&MedicationClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := pm.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(prescriptionmedication.Table, prescriptionmedication.FieldID, id),
			sqlgraph.To(medication.Table, medication.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, prescriptionmedication.MedicationTable, prescriptionmedication.MedicationColumn),
		)
		fromV = sqlgraph.Neighbors(pm.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *PrescriptionMedicationClient) Hooks() []Hook {
	return c.hooks.PrescriptionMedication
}

// Interceptors returns the client interceptors.
func (c *PrescriptionMedicationClient) Interceptors() []Interceptor {
	return c.inters.PrescriptionMedication
}

func (c *PrescriptionMedicationClient) mutate(ctx context.Context, m *PrescriptionMedicationMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&PrescriptionMedicationCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&PrescriptionMedicationUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&PrescriptionMedicationUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&PrescriptionMedicationDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown PrescriptionMedication mutation op: %q", m.Op())
	}
}

// hooks and interceptors per client, for fast access.
type (
	hooks struct {
		MedicalHistories, MedicalPrescription, MedicalSurgery, MedicalTreatment,
		Medication, Patient, PrescriptionMedication []ent.Hook
	}
	inters struct {
		MedicalHistories, MedicalPrescription, MedicalSurgery, MedicalTreatment,
		Medication, Patient, PrescriptionMedication []ent.Interceptor
	}
)
