// Code generated by ent, DO NOT EDIT.

package ent

import (
	"context"
	"errors"
	"fmt"
	"log"
	"reflect"

	"patient/ent/migrate"

	"patient/ent/examinedetail"
	"patient/ent/examinemedication"
	"patient/ent/inpatient"
	"patient/ent/inpatientdetail"
	"patient/ent/invoice"
	"patient/ent/medication"
	"patient/ent/medicationeffect"
	"patient/ent/outpatient"
	"patient/ent/outpatientdetail"
	"patient/ent/patient"
	"patient/ent/treatdetail"
	"patient/ent/treatmedication"

	"entgo.io/ent"
	"entgo.io/ent/dialect"
	"entgo.io/ent/dialect/sql"
	"github.com/google/uuid"
)

// Client is the client that holds all ent builders.
type Client struct {
	config
	// Schema is the client for creating, migrating and dropping schema.
	Schema *migrate.Schema
	// ExamineDetail is the client for interacting with the ExamineDetail builders.
	ExamineDetail *ExamineDetailClient
	// ExamineMedication is the client for interacting with the ExamineMedication builders.
	ExamineMedication *ExamineMedicationClient
	// Inpatient is the client for interacting with the Inpatient builders.
	Inpatient *InpatientClient
	// InpatientDetail is the client for interacting with the InpatientDetail builders.
	InpatientDetail *InpatientDetailClient
	// Invoice is the client for interacting with the Invoice builders.
	Invoice *InvoiceClient
	// Medication is the client for interacting with the Medication builders.
	Medication *MedicationClient
	// MedicationEffect is the client for interacting with the MedicationEffect builders.
	MedicationEffect *MedicationEffectClient
	// Outpatient is the client for interacting with the Outpatient builders.
	Outpatient *OutpatientClient
	// OutpatientDetail is the client for interacting with the OutpatientDetail builders.
	OutpatientDetail *OutpatientDetailClient
	// Patient is the client for interacting with the Patient builders.
	Patient *PatientClient
	// TreatDetail is the client for interacting with the TreatDetail builders.
	TreatDetail *TreatDetailClient
	// TreatMedication is the client for interacting with the TreatMedication builders.
	TreatMedication *TreatMedicationClient
}

// NewClient creates a new client configured with the given options.
func NewClient(opts ...Option) *Client {
	client := &Client{config: newConfig(opts...)}
	client.init()
	return client
}

func (c *Client) init() {
	c.Schema = migrate.NewSchema(c.driver)
	c.ExamineDetail = NewExamineDetailClient(c.config)
	c.ExamineMedication = NewExamineMedicationClient(c.config)
	c.Inpatient = NewInpatientClient(c.config)
	c.InpatientDetail = NewInpatientDetailClient(c.config)
	c.Invoice = NewInvoiceClient(c.config)
	c.Medication = NewMedicationClient(c.config)
	c.MedicationEffect = NewMedicationEffectClient(c.config)
	c.Outpatient = NewOutpatientClient(c.config)
	c.OutpatientDetail = NewOutpatientDetailClient(c.config)
	c.Patient = NewPatientClient(c.config)
	c.TreatDetail = NewTreatDetailClient(c.config)
	c.TreatMedication = NewTreatMedicationClient(c.config)
}

type (
	// config is the configuration for the client and its builder.
	config struct {
		// driver used for executing database requests.
		driver dialect.Driver
		// debug enable a debug logging.
		debug bool
		// log used for logging on debug mode.
		log func(...any)
		// hooks to execute on mutations.
		hooks *hooks
		// interceptors to execute on queries.
		inters *inters
	}
	// Option function to configure the client.
	Option func(*config)
)

// newConfig creates a new config for the client.
func newConfig(opts ...Option) config {
	cfg := config{log: log.Println, hooks: &hooks{}, inters: &inters{}}
	cfg.options(opts...)
	return cfg
}

// options applies the options on the config object.
func (c *config) options(opts ...Option) {
	for _, opt := range opts {
		opt(c)
	}
	if c.debug {
		c.driver = dialect.Debug(c.driver, c.log)
	}
}

// Debug enables debug logging on the ent.Driver.
func Debug() Option {
	return func(c *config) {
		c.debug = true
	}
}

// Log sets the logging function for debug mode.
func Log(fn func(...any)) Option {
	return func(c *config) {
		c.log = fn
	}
}

// Driver configures the client driver.
func Driver(driver dialect.Driver) Option {
	return func(c *config) {
		c.driver = driver
	}
}

// Open opens a database/sql.DB specified by the driver name and
// the data source name, and returns a new client attached to it.
// Optional parameters can be added for configuring the client.
func Open(driverName, dataSourceName string, options ...Option) (*Client, error) {
	switch driverName {
	case dialect.MySQL, dialect.Postgres, dialect.SQLite:
		drv, err := sql.Open(driverName, dataSourceName)
		if err != nil {
			return nil, err
		}
		return NewClient(append(options, Driver(drv))...), nil
	default:
		return nil, fmt.Errorf("unsupported driver: %q", driverName)
	}
}

// ErrTxStarted is returned when trying to start a new transaction from a transactional client.
var ErrTxStarted = errors.New("ent: cannot start a transaction within a transaction")

// Tx returns a new transactional client. The provided context
// is used until the transaction is committed or rolled back.
func (c *Client) Tx(ctx context.Context) (*Tx, error) {
	if _, ok := c.driver.(*txDriver); ok {
		return nil, ErrTxStarted
	}
	tx, err := newTx(ctx, c.driver)
	if err != nil {
		return nil, fmt.Errorf("ent: starting a transaction: %w", err)
	}
	cfg := c.config
	cfg.driver = tx
	return &Tx{
		ctx:               ctx,
		config:            cfg,
		ExamineDetail:     NewExamineDetailClient(cfg),
		ExamineMedication: NewExamineMedicationClient(cfg),
		Inpatient:         NewInpatientClient(cfg),
		InpatientDetail:   NewInpatientDetailClient(cfg),
		Invoice:           NewInvoiceClient(cfg),
		Medication:        NewMedicationClient(cfg),
		MedicationEffect:  NewMedicationEffectClient(cfg),
		Outpatient:        NewOutpatientClient(cfg),
		OutpatientDetail:  NewOutpatientDetailClient(cfg),
		Patient:           NewPatientClient(cfg),
		TreatDetail:       NewTreatDetailClient(cfg),
		TreatMedication:   NewTreatMedicationClient(cfg),
	}, nil
}

// BeginTx returns a transactional client with specified options.
func (c *Client) BeginTx(ctx context.Context, opts *sql.TxOptions) (*Tx, error) {
	if _, ok := c.driver.(*txDriver); ok {
		return nil, errors.New("ent: cannot start a transaction within a transaction")
	}
	tx, err := c.driver.(interface {
		BeginTx(context.Context, *sql.TxOptions) (dialect.Tx, error)
	}).BeginTx(ctx, opts)
	if err != nil {
		return nil, fmt.Errorf("ent: starting a transaction: %w", err)
	}
	cfg := c.config
	cfg.driver = &txDriver{tx: tx, drv: c.driver}
	return &Tx{
		ctx:               ctx,
		config:            cfg,
		ExamineDetail:     NewExamineDetailClient(cfg),
		ExamineMedication: NewExamineMedicationClient(cfg),
		Inpatient:         NewInpatientClient(cfg),
		InpatientDetail:   NewInpatientDetailClient(cfg),
		Invoice:           NewInvoiceClient(cfg),
		Medication:        NewMedicationClient(cfg),
		MedicationEffect:  NewMedicationEffectClient(cfg),
		Outpatient:        NewOutpatientClient(cfg),
		OutpatientDetail:  NewOutpatientDetailClient(cfg),
		Patient:           NewPatientClient(cfg),
		TreatDetail:       NewTreatDetailClient(cfg),
		TreatMedication:   NewTreatMedicationClient(cfg),
	}, nil
}

// Debug returns a new debug-client. It's used to get verbose logging on specific operations.
//
//	client.Debug().
//		ExamineDetail.
//		Query().
//		Count(ctx)
func (c *Client) Debug() *Client {
	if c.debug {
		return c
	}
	cfg := c.config
	cfg.driver = dialect.Debug(c.driver, c.log)
	client := &Client{config: cfg}
	client.init()
	return client
}

// Close closes the database connection and prevents new queries from starting.
func (c *Client) Close() error {
	return c.driver.Close()
}

// Use adds the mutation hooks to all the entity clients.
// In order to add hooks to a specific client, call: `client.Node.Use(...)`.
func (c *Client) Use(hooks ...Hook) {
	for _, n := range []interface{ Use(...Hook) }{
		c.ExamineDetail, c.ExamineMedication, c.Inpatient, c.InpatientDetail, c.Invoice,
		c.Medication, c.MedicationEffect, c.Outpatient, c.OutpatientDetail, c.Patient,
		c.TreatDetail, c.TreatMedication,
	} {
		n.Use(hooks...)
	}
}

// Intercept adds the query interceptors to all the entity clients.
// In order to add interceptors to a specific client, call: `client.Node.Intercept(...)`.
func (c *Client) Intercept(interceptors ...Interceptor) {
	for _, n := range []interface{ Intercept(...Interceptor) }{
		c.ExamineDetail, c.ExamineMedication, c.Inpatient, c.InpatientDetail, c.Invoice,
		c.Medication, c.MedicationEffect, c.Outpatient, c.OutpatientDetail, c.Patient,
		c.TreatDetail, c.TreatMedication,
	} {
		n.Intercept(interceptors...)
	}
}

// Mutate implements the ent.Mutator interface.
func (c *Client) Mutate(ctx context.Context, m Mutation) (Value, error) {
	switch m := m.(type) {
	case *ExamineDetailMutation:
		return c.ExamineDetail.mutate(ctx, m)
	case *ExamineMedicationMutation:
		return c.ExamineMedication.mutate(ctx, m)
	case *InpatientMutation:
		return c.Inpatient.mutate(ctx, m)
	case *InpatientDetailMutation:
		return c.InpatientDetail.mutate(ctx, m)
	case *InvoiceMutation:
		return c.Invoice.mutate(ctx, m)
	case *MedicationMutation:
		return c.Medication.mutate(ctx, m)
	case *MedicationEffectMutation:
		return c.MedicationEffect.mutate(ctx, m)
	case *OutpatientMutation:
		return c.Outpatient.mutate(ctx, m)
	case *OutpatientDetailMutation:
		return c.OutpatientDetail.mutate(ctx, m)
	case *PatientMutation:
		return c.Patient.mutate(ctx, m)
	case *TreatDetailMutation:
		return c.TreatDetail.mutate(ctx, m)
	case *TreatMedicationMutation:
		return c.TreatMedication.mutate(ctx, m)
	default:
		return nil, fmt.Errorf("ent: unknown mutation type %T", m)
	}
}

// ExamineDetailClient is a client for the ExamineDetail schema.
type ExamineDetailClient struct {
	config
}

// NewExamineDetailClient returns a client for the ExamineDetail from the given config.
func NewExamineDetailClient(c config) *ExamineDetailClient {
	return &ExamineDetailClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `examinedetail.Hooks(f(g(h())))`.
func (c *ExamineDetailClient) Use(hooks ...Hook) {
	c.hooks.ExamineDetail = append(c.hooks.ExamineDetail, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `examinedetail.Intercept(f(g(h())))`.
func (c *ExamineDetailClient) Intercept(interceptors ...Interceptor) {
	c.inters.ExamineDetail = append(c.inters.ExamineDetail, interceptors...)
}

// Create returns a builder for creating a ExamineDetail entity.
func (c *ExamineDetailClient) Create() *ExamineDetailCreate {
	mutation := newExamineDetailMutation(c.config, OpCreate)
	return &ExamineDetailCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of ExamineDetail entities.
func (c *ExamineDetailClient) CreateBulk(builders ...*ExamineDetailCreate) *ExamineDetailCreateBulk {
	return &ExamineDetailCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *ExamineDetailClient) MapCreateBulk(slice any, setFunc func(*ExamineDetailCreate, int)) *ExamineDetailCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &ExamineDetailCreateBulk{err: fmt.Errorf("calling to ExamineDetailClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*ExamineDetailCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &ExamineDetailCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for ExamineDetail.
func (c *ExamineDetailClient) Update() *ExamineDetailUpdate {
	mutation := newExamineDetailMutation(c.config, OpUpdate)
	return &ExamineDetailUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *ExamineDetailClient) UpdateOne(ed *ExamineDetail) *ExamineDetailUpdateOne {
	mutation := newExamineDetailMutation(c.config, OpUpdateOne, withExamineDetail(ed))
	return &ExamineDetailUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *ExamineDetailClient) UpdateOneID(id int) *ExamineDetailUpdateOne {
	mutation := newExamineDetailMutation(c.config, OpUpdateOne, withExamineDetailID(id))
	return &ExamineDetailUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for ExamineDetail.
func (c *ExamineDetailClient) Delete() *ExamineDetailDelete {
	mutation := newExamineDetailMutation(c.config, OpDelete)
	return &ExamineDetailDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *ExamineDetailClient) DeleteOne(ed *ExamineDetail) *ExamineDetailDeleteOne {
	return c.DeleteOneID(ed.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *ExamineDetailClient) DeleteOneID(id int) *ExamineDetailDeleteOne {
	builder := c.Delete().Where(examinedetail.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &ExamineDetailDeleteOne{builder}
}

// Query returns a query builder for ExamineDetail.
func (c *ExamineDetailClient) Query() *ExamineDetailQuery {
	return &ExamineDetailQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeExamineDetail},
		inters: c.Interceptors(),
	}
}

// Get returns a ExamineDetail entity by its id.
func (c *ExamineDetailClient) Get(ctx context.Context, id int) (*ExamineDetail, error) {
	return c.Query().Where(examinedetail.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *ExamineDetailClient) GetX(ctx context.Context, id int) *ExamineDetail {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// Hooks returns the client hooks.
func (c *ExamineDetailClient) Hooks() []Hook {
	return c.hooks.ExamineDetail
}

// Interceptors returns the client interceptors.
func (c *ExamineDetailClient) Interceptors() []Interceptor {
	return c.inters.ExamineDetail
}

func (c *ExamineDetailClient) mutate(ctx context.Context, m *ExamineDetailMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&ExamineDetailCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&ExamineDetailUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&ExamineDetailUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&ExamineDetailDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown ExamineDetail mutation op: %q", m.Op())
	}
}

// ExamineMedicationClient is a client for the ExamineMedication schema.
type ExamineMedicationClient struct {
	config
}

// NewExamineMedicationClient returns a client for the ExamineMedication from the given config.
func NewExamineMedicationClient(c config) *ExamineMedicationClient {
	return &ExamineMedicationClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `examinemedication.Hooks(f(g(h())))`.
func (c *ExamineMedicationClient) Use(hooks ...Hook) {
	c.hooks.ExamineMedication = append(c.hooks.ExamineMedication, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `examinemedication.Intercept(f(g(h())))`.
func (c *ExamineMedicationClient) Intercept(interceptors ...Interceptor) {
	c.inters.ExamineMedication = append(c.inters.ExamineMedication, interceptors...)
}

// Create returns a builder for creating a ExamineMedication entity.
func (c *ExamineMedicationClient) Create() *ExamineMedicationCreate {
	mutation := newExamineMedicationMutation(c.config, OpCreate)
	return &ExamineMedicationCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of ExamineMedication entities.
func (c *ExamineMedicationClient) CreateBulk(builders ...*ExamineMedicationCreate) *ExamineMedicationCreateBulk {
	return &ExamineMedicationCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *ExamineMedicationClient) MapCreateBulk(slice any, setFunc func(*ExamineMedicationCreate, int)) *ExamineMedicationCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &ExamineMedicationCreateBulk{err: fmt.Errorf("calling to ExamineMedicationClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*ExamineMedicationCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &ExamineMedicationCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for ExamineMedication.
func (c *ExamineMedicationClient) Update() *ExamineMedicationUpdate {
	mutation := newExamineMedicationMutation(c.config, OpUpdate)
	return &ExamineMedicationUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *ExamineMedicationClient) UpdateOne(em *ExamineMedication) *ExamineMedicationUpdateOne {
	mutation := newExamineMedicationMutation(c.config, OpUpdateOne, withExamineMedication(em))
	return &ExamineMedicationUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *ExamineMedicationClient) UpdateOneID(id int) *ExamineMedicationUpdateOne {
	mutation := newExamineMedicationMutation(c.config, OpUpdateOne, withExamineMedicationID(id))
	return &ExamineMedicationUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for ExamineMedication.
func (c *ExamineMedicationClient) Delete() *ExamineMedicationDelete {
	mutation := newExamineMedicationMutation(c.config, OpDelete)
	return &ExamineMedicationDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *ExamineMedicationClient) DeleteOne(em *ExamineMedication) *ExamineMedicationDeleteOne {
	return c.DeleteOneID(em.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *ExamineMedicationClient) DeleteOneID(id int) *ExamineMedicationDeleteOne {
	builder := c.Delete().Where(examinemedication.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &ExamineMedicationDeleteOne{builder}
}

// Query returns a query builder for ExamineMedication.
func (c *ExamineMedicationClient) Query() *ExamineMedicationQuery {
	return &ExamineMedicationQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeExamineMedication},
		inters: c.Interceptors(),
	}
}

// Get returns a ExamineMedication entity by its id.
func (c *ExamineMedicationClient) Get(ctx context.Context, id int) (*ExamineMedication, error) {
	return c.Query().Where(examinemedication.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *ExamineMedicationClient) GetX(ctx context.Context, id int) *ExamineMedication {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// Hooks returns the client hooks.
func (c *ExamineMedicationClient) Hooks() []Hook {
	return c.hooks.ExamineMedication
}

// Interceptors returns the client interceptors.
func (c *ExamineMedicationClient) Interceptors() []Interceptor {
	return c.inters.ExamineMedication
}

func (c *ExamineMedicationClient) mutate(ctx context.Context, m *ExamineMedicationMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&ExamineMedicationCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&ExamineMedicationUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&ExamineMedicationUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&ExamineMedicationDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown ExamineMedication mutation op: %q", m.Op())
	}
}

// InpatientClient is a client for the Inpatient schema.
type InpatientClient struct {
	config
}

// NewInpatientClient returns a client for the Inpatient from the given config.
func NewInpatientClient(c config) *InpatientClient {
	return &InpatientClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `inpatient.Hooks(f(g(h())))`.
func (c *InpatientClient) Use(hooks ...Hook) {
	c.hooks.Inpatient = append(c.hooks.Inpatient, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `inpatient.Intercept(f(g(h())))`.
func (c *InpatientClient) Intercept(interceptors ...Interceptor) {
	c.inters.Inpatient = append(c.inters.Inpatient, interceptors...)
}

// Create returns a builder for creating a Inpatient entity.
func (c *InpatientClient) Create() *InpatientCreate {
	mutation := newInpatientMutation(c.config, OpCreate)
	return &InpatientCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Inpatient entities.
func (c *InpatientClient) CreateBulk(builders ...*InpatientCreate) *InpatientCreateBulk {
	return &InpatientCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *InpatientClient) MapCreateBulk(slice any, setFunc func(*InpatientCreate, int)) *InpatientCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &InpatientCreateBulk{err: fmt.Errorf("calling to InpatientClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*InpatientCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &InpatientCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Inpatient.
func (c *InpatientClient) Update() *InpatientUpdate {
	mutation := newInpatientMutation(c.config, OpUpdate)
	return &InpatientUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *InpatientClient) UpdateOne(i *Inpatient) *InpatientUpdateOne {
	mutation := newInpatientMutation(c.config, OpUpdateOne, withInpatient(i))
	return &InpatientUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *InpatientClient) UpdateOneID(id int) *InpatientUpdateOne {
	mutation := newInpatientMutation(c.config, OpUpdateOne, withInpatientID(id))
	return &InpatientUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Inpatient.
func (c *InpatientClient) Delete() *InpatientDelete {
	mutation := newInpatientMutation(c.config, OpDelete)
	return &InpatientDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *InpatientClient) DeleteOne(i *Inpatient) *InpatientDeleteOne {
	return c.DeleteOneID(i.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *InpatientClient) DeleteOneID(id int) *InpatientDeleteOne {
	builder := c.Delete().Where(inpatient.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &InpatientDeleteOne{builder}
}

// Query returns a query builder for Inpatient.
func (c *InpatientClient) Query() *InpatientQuery {
	return &InpatientQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeInpatient},
		inters: c.Interceptors(),
	}
}

// Get returns a Inpatient entity by its id.
func (c *InpatientClient) Get(ctx context.Context, id int) (*Inpatient, error) {
	return c.Query().Where(inpatient.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *InpatientClient) GetX(ctx context.Context, id int) *Inpatient {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// Hooks returns the client hooks.
func (c *InpatientClient) Hooks() []Hook {
	return c.hooks.Inpatient
}

// Interceptors returns the client interceptors.
func (c *InpatientClient) Interceptors() []Interceptor {
	return c.inters.Inpatient
}

func (c *InpatientClient) mutate(ctx context.Context, m *InpatientMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&InpatientCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&InpatientUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&InpatientUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&InpatientDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown Inpatient mutation op: %q", m.Op())
	}
}

// InpatientDetailClient is a client for the InpatientDetail schema.
type InpatientDetailClient struct {
	config
}

// NewInpatientDetailClient returns a client for the InpatientDetail from the given config.
func NewInpatientDetailClient(c config) *InpatientDetailClient {
	return &InpatientDetailClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `inpatientdetail.Hooks(f(g(h())))`.
func (c *InpatientDetailClient) Use(hooks ...Hook) {
	c.hooks.InpatientDetail = append(c.hooks.InpatientDetail, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `inpatientdetail.Intercept(f(g(h())))`.
func (c *InpatientDetailClient) Intercept(interceptors ...Interceptor) {
	c.inters.InpatientDetail = append(c.inters.InpatientDetail, interceptors...)
}

// Create returns a builder for creating a InpatientDetail entity.
func (c *InpatientDetailClient) Create() *InpatientDetailCreate {
	mutation := newInpatientDetailMutation(c.config, OpCreate)
	return &InpatientDetailCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of InpatientDetail entities.
func (c *InpatientDetailClient) CreateBulk(builders ...*InpatientDetailCreate) *InpatientDetailCreateBulk {
	return &InpatientDetailCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *InpatientDetailClient) MapCreateBulk(slice any, setFunc func(*InpatientDetailCreate, int)) *InpatientDetailCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &InpatientDetailCreateBulk{err: fmt.Errorf("calling to InpatientDetailClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*InpatientDetailCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &InpatientDetailCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for InpatientDetail.
func (c *InpatientDetailClient) Update() *InpatientDetailUpdate {
	mutation := newInpatientDetailMutation(c.config, OpUpdate)
	return &InpatientDetailUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *InpatientDetailClient) UpdateOne(id *InpatientDetail) *InpatientDetailUpdateOne {
	mutation := newInpatientDetailMutation(c.config, OpUpdateOne, withInpatientDetail(id))
	return &InpatientDetailUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *InpatientDetailClient) UpdateOneID(id int) *InpatientDetailUpdateOne {
	mutation := newInpatientDetailMutation(c.config, OpUpdateOne, withInpatientDetailID(id))
	return &InpatientDetailUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for InpatientDetail.
func (c *InpatientDetailClient) Delete() *InpatientDetailDelete {
	mutation := newInpatientDetailMutation(c.config, OpDelete)
	return &InpatientDetailDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *InpatientDetailClient) DeleteOne(id *InpatientDetail) *InpatientDetailDeleteOne {
	return c.DeleteOneID(id.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *InpatientDetailClient) DeleteOneID(id int) *InpatientDetailDeleteOne {
	builder := c.Delete().Where(inpatientdetail.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &InpatientDetailDeleteOne{builder}
}

// Query returns a query builder for InpatientDetail.
func (c *InpatientDetailClient) Query() *InpatientDetailQuery {
	return &InpatientDetailQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeInpatientDetail},
		inters: c.Interceptors(),
	}
}

// Get returns a InpatientDetail entity by its id.
func (c *InpatientDetailClient) Get(ctx context.Context, id int) (*InpatientDetail, error) {
	return c.Query().Where(inpatientdetail.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *InpatientDetailClient) GetX(ctx context.Context, id int) *InpatientDetail {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// Hooks returns the client hooks.
func (c *InpatientDetailClient) Hooks() []Hook {
	return c.hooks.InpatientDetail
}

// Interceptors returns the client interceptors.
func (c *InpatientDetailClient) Interceptors() []Interceptor {
	return c.inters.InpatientDetail
}

func (c *InpatientDetailClient) mutate(ctx context.Context, m *InpatientDetailMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&InpatientDetailCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&InpatientDetailUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&InpatientDetailUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&InpatientDetailDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown InpatientDetail mutation op: %q", m.Op())
	}
}

// InvoiceClient is a client for the Invoice schema.
type InvoiceClient struct {
	config
}

// NewInvoiceClient returns a client for the Invoice from the given config.
func NewInvoiceClient(c config) *InvoiceClient {
	return &InvoiceClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `invoice.Hooks(f(g(h())))`.
func (c *InvoiceClient) Use(hooks ...Hook) {
	c.hooks.Invoice = append(c.hooks.Invoice, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `invoice.Intercept(f(g(h())))`.
func (c *InvoiceClient) Intercept(interceptors ...Interceptor) {
	c.inters.Invoice = append(c.inters.Invoice, interceptors...)
}

// Create returns a builder for creating a Invoice entity.
func (c *InvoiceClient) Create() *InvoiceCreate {
	mutation := newInvoiceMutation(c.config, OpCreate)
	return &InvoiceCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Invoice entities.
func (c *InvoiceClient) CreateBulk(builders ...*InvoiceCreate) *InvoiceCreateBulk {
	return &InvoiceCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *InvoiceClient) MapCreateBulk(slice any, setFunc func(*InvoiceCreate, int)) *InvoiceCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &InvoiceCreateBulk{err: fmt.Errorf("calling to InvoiceClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*InvoiceCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &InvoiceCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Invoice.
func (c *InvoiceClient) Update() *InvoiceUpdate {
	mutation := newInvoiceMutation(c.config, OpUpdate)
	return &InvoiceUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *InvoiceClient) UpdateOne(i *Invoice) *InvoiceUpdateOne {
	mutation := newInvoiceMutation(c.config, OpUpdateOne, withInvoice(i))
	return &InvoiceUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *InvoiceClient) UpdateOneID(id int) *InvoiceUpdateOne {
	mutation := newInvoiceMutation(c.config, OpUpdateOne, withInvoiceID(id))
	return &InvoiceUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Invoice.
func (c *InvoiceClient) Delete() *InvoiceDelete {
	mutation := newInvoiceMutation(c.config, OpDelete)
	return &InvoiceDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *InvoiceClient) DeleteOne(i *Invoice) *InvoiceDeleteOne {
	return c.DeleteOneID(i.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *InvoiceClient) DeleteOneID(id int) *InvoiceDeleteOne {
	builder := c.Delete().Where(invoice.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &InvoiceDeleteOne{builder}
}

// Query returns a query builder for Invoice.
func (c *InvoiceClient) Query() *InvoiceQuery {
	return &InvoiceQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeInvoice},
		inters: c.Interceptors(),
	}
}

// Get returns a Invoice entity by its id.
func (c *InvoiceClient) Get(ctx context.Context, id int) (*Invoice, error) {
	return c.Query().Where(invoice.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *InvoiceClient) GetX(ctx context.Context, id int) *Invoice {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// Hooks returns the client hooks.
func (c *InvoiceClient) Hooks() []Hook {
	return c.hooks.Invoice
}

// Interceptors returns the client interceptors.
func (c *InvoiceClient) Interceptors() []Interceptor {
	return c.inters.Invoice
}

func (c *InvoiceClient) mutate(ctx context.Context, m *InvoiceMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&InvoiceCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&InvoiceUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&InvoiceUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&InvoiceDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown Invoice mutation op: %q", m.Op())
	}
}

// MedicationClient is a client for the Medication schema.
type MedicationClient struct {
	config
}

// NewMedicationClient returns a client for the Medication from the given config.
func NewMedicationClient(c config) *MedicationClient {
	return &MedicationClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `medication.Hooks(f(g(h())))`.
func (c *MedicationClient) Use(hooks ...Hook) {
	c.hooks.Medication = append(c.hooks.Medication, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `medication.Intercept(f(g(h())))`.
func (c *MedicationClient) Intercept(interceptors ...Interceptor) {
	c.inters.Medication = append(c.inters.Medication, interceptors...)
}

// Create returns a builder for creating a Medication entity.
func (c *MedicationClient) Create() *MedicationCreate {
	mutation := newMedicationMutation(c.config, OpCreate)
	return &MedicationCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Medication entities.
func (c *MedicationClient) CreateBulk(builders ...*MedicationCreate) *MedicationCreateBulk {
	return &MedicationCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *MedicationClient) MapCreateBulk(slice any, setFunc func(*MedicationCreate, int)) *MedicationCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &MedicationCreateBulk{err: fmt.Errorf("calling to MedicationClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*MedicationCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &MedicationCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Medication.
func (c *MedicationClient) Update() *MedicationUpdate {
	mutation := newMedicationMutation(c.config, OpUpdate)
	return &MedicationUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *MedicationClient) UpdateOne(m *Medication) *MedicationUpdateOne {
	mutation := newMedicationMutation(c.config, OpUpdateOne, withMedication(m))
	return &MedicationUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *MedicationClient) UpdateOneID(id int) *MedicationUpdateOne {
	mutation := newMedicationMutation(c.config, OpUpdateOne, withMedicationID(id))
	return &MedicationUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Medication.
func (c *MedicationClient) Delete() *MedicationDelete {
	mutation := newMedicationMutation(c.config, OpDelete)
	return &MedicationDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *MedicationClient) DeleteOne(m *Medication) *MedicationDeleteOne {
	return c.DeleteOneID(m.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *MedicationClient) DeleteOneID(id int) *MedicationDeleteOne {
	builder := c.Delete().Where(medication.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &MedicationDeleteOne{builder}
}

// Query returns a query builder for Medication.
func (c *MedicationClient) Query() *MedicationQuery {
	return &MedicationQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeMedication},
		inters: c.Interceptors(),
	}
}

// Get returns a Medication entity by its id.
func (c *MedicationClient) Get(ctx context.Context, id int) (*Medication, error) {
	return c.Query().Where(medication.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *MedicationClient) GetX(ctx context.Context, id int) *Medication {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// Hooks returns the client hooks.
func (c *MedicationClient) Hooks() []Hook {
	return c.hooks.Medication
}

// Interceptors returns the client interceptors.
func (c *MedicationClient) Interceptors() []Interceptor {
	return c.inters.Medication
}

func (c *MedicationClient) mutate(ctx context.Context, m *MedicationMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&MedicationCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&MedicationUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&MedicationUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&MedicationDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown Medication mutation op: %q", m.Op())
	}
}

// MedicationEffectClient is a client for the MedicationEffect schema.
type MedicationEffectClient struct {
	config
}

// NewMedicationEffectClient returns a client for the MedicationEffect from the given config.
func NewMedicationEffectClient(c config) *MedicationEffectClient {
	return &MedicationEffectClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `medicationeffect.Hooks(f(g(h())))`.
func (c *MedicationEffectClient) Use(hooks ...Hook) {
	c.hooks.MedicationEffect = append(c.hooks.MedicationEffect, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `medicationeffect.Intercept(f(g(h())))`.
func (c *MedicationEffectClient) Intercept(interceptors ...Interceptor) {
	c.inters.MedicationEffect = append(c.inters.MedicationEffect, interceptors...)
}

// Create returns a builder for creating a MedicationEffect entity.
func (c *MedicationEffectClient) Create() *MedicationEffectCreate {
	mutation := newMedicationEffectMutation(c.config, OpCreate)
	return &MedicationEffectCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of MedicationEffect entities.
func (c *MedicationEffectClient) CreateBulk(builders ...*MedicationEffectCreate) *MedicationEffectCreateBulk {
	return &MedicationEffectCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *MedicationEffectClient) MapCreateBulk(slice any, setFunc func(*MedicationEffectCreate, int)) *MedicationEffectCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &MedicationEffectCreateBulk{err: fmt.Errorf("calling to MedicationEffectClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*MedicationEffectCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &MedicationEffectCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for MedicationEffect.
func (c *MedicationEffectClient) Update() *MedicationEffectUpdate {
	mutation := newMedicationEffectMutation(c.config, OpUpdate)
	return &MedicationEffectUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *MedicationEffectClient) UpdateOne(me *MedicationEffect) *MedicationEffectUpdateOne {
	mutation := newMedicationEffectMutation(c.config, OpUpdateOne, withMedicationEffect(me))
	return &MedicationEffectUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *MedicationEffectClient) UpdateOneID(id int) *MedicationEffectUpdateOne {
	mutation := newMedicationEffectMutation(c.config, OpUpdateOne, withMedicationEffectID(id))
	return &MedicationEffectUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for MedicationEffect.
func (c *MedicationEffectClient) Delete() *MedicationEffectDelete {
	mutation := newMedicationEffectMutation(c.config, OpDelete)
	return &MedicationEffectDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *MedicationEffectClient) DeleteOne(me *MedicationEffect) *MedicationEffectDeleteOne {
	return c.DeleteOneID(me.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *MedicationEffectClient) DeleteOneID(id int) *MedicationEffectDeleteOne {
	builder := c.Delete().Where(medicationeffect.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &MedicationEffectDeleteOne{builder}
}

// Query returns a query builder for MedicationEffect.
func (c *MedicationEffectClient) Query() *MedicationEffectQuery {
	return &MedicationEffectQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeMedicationEffect},
		inters: c.Interceptors(),
	}
}

// Get returns a MedicationEffect entity by its id.
func (c *MedicationEffectClient) Get(ctx context.Context, id int) (*MedicationEffect, error) {
	return c.Query().Where(medicationeffect.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *MedicationEffectClient) GetX(ctx context.Context, id int) *MedicationEffect {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// Hooks returns the client hooks.
func (c *MedicationEffectClient) Hooks() []Hook {
	return c.hooks.MedicationEffect
}

// Interceptors returns the client interceptors.
func (c *MedicationEffectClient) Interceptors() []Interceptor {
	return c.inters.MedicationEffect
}

func (c *MedicationEffectClient) mutate(ctx context.Context, m *MedicationEffectMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&MedicationEffectCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&MedicationEffectUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&MedicationEffectUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&MedicationEffectDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown MedicationEffect mutation op: %q", m.Op())
	}
}

// OutpatientClient is a client for the Outpatient schema.
type OutpatientClient struct {
	config
}

// NewOutpatientClient returns a client for the Outpatient from the given config.
func NewOutpatientClient(c config) *OutpatientClient {
	return &OutpatientClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `outpatient.Hooks(f(g(h())))`.
func (c *OutpatientClient) Use(hooks ...Hook) {
	c.hooks.Outpatient = append(c.hooks.Outpatient, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `outpatient.Intercept(f(g(h())))`.
func (c *OutpatientClient) Intercept(interceptors ...Interceptor) {
	c.inters.Outpatient = append(c.inters.Outpatient, interceptors...)
}

// Create returns a builder for creating a Outpatient entity.
func (c *OutpatientClient) Create() *OutpatientCreate {
	mutation := newOutpatientMutation(c.config, OpCreate)
	return &OutpatientCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Outpatient entities.
func (c *OutpatientClient) CreateBulk(builders ...*OutpatientCreate) *OutpatientCreateBulk {
	return &OutpatientCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *OutpatientClient) MapCreateBulk(slice any, setFunc func(*OutpatientCreate, int)) *OutpatientCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &OutpatientCreateBulk{err: fmt.Errorf("calling to OutpatientClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*OutpatientCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &OutpatientCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Outpatient.
func (c *OutpatientClient) Update() *OutpatientUpdate {
	mutation := newOutpatientMutation(c.config, OpUpdate)
	return &OutpatientUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *OutpatientClient) UpdateOne(o *Outpatient) *OutpatientUpdateOne {
	mutation := newOutpatientMutation(c.config, OpUpdateOne, withOutpatient(o))
	return &OutpatientUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *OutpatientClient) UpdateOneID(id int) *OutpatientUpdateOne {
	mutation := newOutpatientMutation(c.config, OpUpdateOne, withOutpatientID(id))
	return &OutpatientUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Outpatient.
func (c *OutpatientClient) Delete() *OutpatientDelete {
	mutation := newOutpatientMutation(c.config, OpDelete)
	return &OutpatientDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *OutpatientClient) DeleteOne(o *Outpatient) *OutpatientDeleteOne {
	return c.DeleteOneID(o.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *OutpatientClient) DeleteOneID(id int) *OutpatientDeleteOne {
	builder := c.Delete().Where(outpatient.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &OutpatientDeleteOne{builder}
}

// Query returns a query builder for Outpatient.
func (c *OutpatientClient) Query() *OutpatientQuery {
	return &OutpatientQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeOutpatient},
		inters: c.Interceptors(),
	}
}

// Get returns a Outpatient entity by its id.
func (c *OutpatientClient) Get(ctx context.Context, id int) (*Outpatient, error) {
	return c.Query().Where(outpatient.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *OutpatientClient) GetX(ctx context.Context, id int) *Outpatient {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// Hooks returns the client hooks.
func (c *OutpatientClient) Hooks() []Hook {
	return c.hooks.Outpatient
}

// Interceptors returns the client interceptors.
func (c *OutpatientClient) Interceptors() []Interceptor {
	return c.inters.Outpatient
}

func (c *OutpatientClient) mutate(ctx context.Context, m *OutpatientMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&OutpatientCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&OutpatientUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&OutpatientUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&OutpatientDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown Outpatient mutation op: %q", m.Op())
	}
}

// OutpatientDetailClient is a client for the OutpatientDetail schema.
type OutpatientDetailClient struct {
	config
}

// NewOutpatientDetailClient returns a client for the OutpatientDetail from the given config.
func NewOutpatientDetailClient(c config) *OutpatientDetailClient {
	return &OutpatientDetailClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `outpatientdetail.Hooks(f(g(h())))`.
func (c *OutpatientDetailClient) Use(hooks ...Hook) {
	c.hooks.OutpatientDetail = append(c.hooks.OutpatientDetail, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `outpatientdetail.Intercept(f(g(h())))`.
func (c *OutpatientDetailClient) Intercept(interceptors ...Interceptor) {
	c.inters.OutpatientDetail = append(c.inters.OutpatientDetail, interceptors...)
}

// Create returns a builder for creating a OutpatientDetail entity.
func (c *OutpatientDetailClient) Create() *OutpatientDetailCreate {
	mutation := newOutpatientDetailMutation(c.config, OpCreate)
	return &OutpatientDetailCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of OutpatientDetail entities.
func (c *OutpatientDetailClient) CreateBulk(builders ...*OutpatientDetailCreate) *OutpatientDetailCreateBulk {
	return &OutpatientDetailCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *OutpatientDetailClient) MapCreateBulk(slice any, setFunc func(*OutpatientDetailCreate, int)) *OutpatientDetailCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &OutpatientDetailCreateBulk{err: fmt.Errorf("calling to OutpatientDetailClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*OutpatientDetailCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &OutpatientDetailCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for OutpatientDetail.
func (c *OutpatientDetailClient) Update() *OutpatientDetailUpdate {
	mutation := newOutpatientDetailMutation(c.config, OpUpdate)
	return &OutpatientDetailUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *OutpatientDetailClient) UpdateOne(od *OutpatientDetail) *OutpatientDetailUpdateOne {
	mutation := newOutpatientDetailMutation(c.config, OpUpdateOne, withOutpatientDetail(od))
	return &OutpatientDetailUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *OutpatientDetailClient) UpdateOneID(id int) *OutpatientDetailUpdateOne {
	mutation := newOutpatientDetailMutation(c.config, OpUpdateOne, withOutpatientDetailID(id))
	return &OutpatientDetailUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for OutpatientDetail.
func (c *OutpatientDetailClient) Delete() *OutpatientDetailDelete {
	mutation := newOutpatientDetailMutation(c.config, OpDelete)
	return &OutpatientDetailDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *OutpatientDetailClient) DeleteOne(od *OutpatientDetail) *OutpatientDetailDeleteOne {
	return c.DeleteOneID(od.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *OutpatientDetailClient) DeleteOneID(id int) *OutpatientDetailDeleteOne {
	builder := c.Delete().Where(outpatientdetail.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &OutpatientDetailDeleteOne{builder}
}

// Query returns a query builder for OutpatientDetail.
func (c *OutpatientDetailClient) Query() *OutpatientDetailQuery {
	return &OutpatientDetailQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeOutpatientDetail},
		inters: c.Interceptors(),
	}
}

// Get returns a OutpatientDetail entity by its id.
func (c *OutpatientDetailClient) Get(ctx context.Context, id int) (*OutpatientDetail, error) {
	return c.Query().Where(outpatientdetail.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *OutpatientDetailClient) GetX(ctx context.Context, id int) *OutpatientDetail {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// Hooks returns the client hooks.
func (c *OutpatientDetailClient) Hooks() []Hook {
	return c.hooks.OutpatientDetail
}

// Interceptors returns the client interceptors.
func (c *OutpatientDetailClient) Interceptors() []Interceptor {
	return c.inters.OutpatientDetail
}

func (c *OutpatientDetailClient) mutate(ctx context.Context, m *OutpatientDetailMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&OutpatientDetailCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&OutpatientDetailUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&OutpatientDetailUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&OutpatientDetailDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown OutpatientDetail mutation op: %q", m.Op())
	}
}

// PatientClient is a client for the Patient schema.
type PatientClient struct {
	config
}

// NewPatientClient returns a client for the Patient from the given config.
func NewPatientClient(c config) *PatientClient {
	return &PatientClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `patient.Hooks(f(g(h())))`.
func (c *PatientClient) Use(hooks ...Hook) {
	c.hooks.Patient = append(c.hooks.Patient, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `patient.Intercept(f(g(h())))`.
func (c *PatientClient) Intercept(interceptors ...Interceptor) {
	c.inters.Patient = append(c.inters.Patient, interceptors...)
}

// Create returns a builder for creating a Patient entity.
func (c *PatientClient) Create() *PatientCreate {
	mutation := newPatientMutation(c.config, OpCreate)
	return &PatientCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Patient entities.
func (c *PatientClient) CreateBulk(builders ...*PatientCreate) *PatientCreateBulk {
	return &PatientCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *PatientClient) MapCreateBulk(slice any, setFunc func(*PatientCreate, int)) *PatientCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &PatientCreateBulk{err: fmt.Errorf("calling to PatientClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*PatientCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &PatientCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Patient.
func (c *PatientClient) Update() *PatientUpdate {
	mutation := newPatientMutation(c.config, OpUpdate)
	return &PatientUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *PatientClient) UpdateOne(pa *Patient) *PatientUpdateOne {
	mutation := newPatientMutation(c.config, OpUpdateOne, withPatient(pa))
	return &PatientUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *PatientClient) UpdateOneID(id uuid.UUID) *PatientUpdateOne {
	mutation := newPatientMutation(c.config, OpUpdateOne, withPatientID(id))
	return &PatientUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Patient.
func (c *PatientClient) Delete() *PatientDelete {
	mutation := newPatientMutation(c.config, OpDelete)
	return &PatientDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *PatientClient) DeleteOne(pa *Patient) *PatientDeleteOne {
	return c.DeleteOneID(pa.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *PatientClient) DeleteOneID(id uuid.UUID) *PatientDeleteOne {
	builder := c.Delete().Where(patient.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &PatientDeleteOne{builder}
}

// Query returns a query builder for Patient.
func (c *PatientClient) Query() *PatientQuery {
	return &PatientQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypePatient},
		inters: c.Interceptors(),
	}
}

// Get returns a Patient entity by its id.
func (c *PatientClient) Get(ctx context.Context, id uuid.UUID) (*Patient, error) {
	return c.Query().Where(patient.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *PatientClient) GetX(ctx context.Context, id uuid.UUID) *Patient {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// Hooks returns the client hooks.
func (c *PatientClient) Hooks() []Hook {
	return c.hooks.Patient
}

// Interceptors returns the client interceptors.
func (c *PatientClient) Interceptors() []Interceptor {
	return c.inters.Patient
}

func (c *PatientClient) mutate(ctx context.Context, m *PatientMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&PatientCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&PatientUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&PatientUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&PatientDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown Patient mutation op: %q", m.Op())
	}
}

// TreatDetailClient is a client for the TreatDetail schema.
type TreatDetailClient struct {
	config
}

// NewTreatDetailClient returns a client for the TreatDetail from the given config.
func NewTreatDetailClient(c config) *TreatDetailClient {
	return &TreatDetailClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `treatdetail.Hooks(f(g(h())))`.
func (c *TreatDetailClient) Use(hooks ...Hook) {
	c.hooks.TreatDetail = append(c.hooks.TreatDetail, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `treatdetail.Intercept(f(g(h())))`.
func (c *TreatDetailClient) Intercept(interceptors ...Interceptor) {
	c.inters.TreatDetail = append(c.inters.TreatDetail, interceptors...)
}

// Create returns a builder for creating a TreatDetail entity.
func (c *TreatDetailClient) Create() *TreatDetailCreate {
	mutation := newTreatDetailMutation(c.config, OpCreate)
	return &TreatDetailCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of TreatDetail entities.
func (c *TreatDetailClient) CreateBulk(builders ...*TreatDetailCreate) *TreatDetailCreateBulk {
	return &TreatDetailCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *TreatDetailClient) MapCreateBulk(slice any, setFunc func(*TreatDetailCreate, int)) *TreatDetailCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &TreatDetailCreateBulk{err: fmt.Errorf("calling to TreatDetailClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*TreatDetailCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &TreatDetailCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for TreatDetail.
func (c *TreatDetailClient) Update() *TreatDetailUpdate {
	mutation := newTreatDetailMutation(c.config, OpUpdate)
	return &TreatDetailUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *TreatDetailClient) UpdateOne(td *TreatDetail) *TreatDetailUpdateOne {
	mutation := newTreatDetailMutation(c.config, OpUpdateOne, withTreatDetail(td))
	return &TreatDetailUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *TreatDetailClient) UpdateOneID(id int) *TreatDetailUpdateOne {
	mutation := newTreatDetailMutation(c.config, OpUpdateOne, withTreatDetailID(id))
	return &TreatDetailUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for TreatDetail.
func (c *TreatDetailClient) Delete() *TreatDetailDelete {
	mutation := newTreatDetailMutation(c.config, OpDelete)
	return &TreatDetailDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *TreatDetailClient) DeleteOne(td *TreatDetail) *TreatDetailDeleteOne {
	return c.DeleteOneID(td.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *TreatDetailClient) DeleteOneID(id int) *TreatDetailDeleteOne {
	builder := c.Delete().Where(treatdetail.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &TreatDetailDeleteOne{builder}
}

// Query returns a query builder for TreatDetail.
func (c *TreatDetailClient) Query() *TreatDetailQuery {
	return &TreatDetailQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeTreatDetail},
		inters: c.Interceptors(),
	}
}

// Get returns a TreatDetail entity by its id.
func (c *TreatDetailClient) Get(ctx context.Context, id int) (*TreatDetail, error) {
	return c.Query().Where(treatdetail.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *TreatDetailClient) GetX(ctx context.Context, id int) *TreatDetail {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// Hooks returns the client hooks.
func (c *TreatDetailClient) Hooks() []Hook {
	return c.hooks.TreatDetail
}

// Interceptors returns the client interceptors.
func (c *TreatDetailClient) Interceptors() []Interceptor {
	return c.inters.TreatDetail
}

func (c *TreatDetailClient) mutate(ctx context.Context, m *TreatDetailMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&TreatDetailCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&TreatDetailUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&TreatDetailUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&TreatDetailDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown TreatDetail mutation op: %q", m.Op())
	}
}

// TreatMedicationClient is a client for the TreatMedication schema.
type TreatMedicationClient struct {
	config
}

// NewTreatMedicationClient returns a client for the TreatMedication from the given config.
func NewTreatMedicationClient(c config) *TreatMedicationClient {
	return &TreatMedicationClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `treatmedication.Hooks(f(g(h())))`.
func (c *TreatMedicationClient) Use(hooks ...Hook) {
	c.hooks.TreatMedication = append(c.hooks.TreatMedication, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `treatmedication.Intercept(f(g(h())))`.
func (c *TreatMedicationClient) Intercept(interceptors ...Interceptor) {
	c.inters.TreatMedication = append(c.inters.TreatMedication, interceptors...)
}

// Create returns a builder for creating a TreatMedication entity.
func (c *TreatMedicationClient) Create() *TreatMedicationCreate {
	mutation := newTreatMedicationMutation(c.config, OpCreate)
	return &TreatMedicationCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of TreatMedication entities.
func (c *TreatMedicationClient) CreateBulk(builders ...*TreatMedicationCreate) *TreatMedicationCreateBulk {
	return &TreatMedicationCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *TreatMedicationClient) MapCreateBulk(slice any, setFunc func(*TreatMedicationCreate, int)) *TreatMedicationCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &TreatMedicationCreateBulk{err: fmt.Errorf("calling to TreatMedicationClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*TreatMedicationCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &TreatMedicationCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for TreatMedication.
func (c *TreatMedicationClient) Update() *TreatMedicationUpdate {
	mutation := newTreatMedicationMutation(c.config, OpUpdate)
	return &TreatMedicationUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *TreatMedicationClient) UpdateOne(tm *TreatMedication) *TreatMedicationUpdateOne {
	mutation := newTreatMedicationMutation(c.config, OpUpdateOne, withTreatMedication(tm))
	return &TreatMedicationUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *TreatMedicationClient) UpdateOneID(id int) *TreatMedicationUpdateOne {
	mutation := newTreatMedicationMutation(c.config, OpUpdateOne, withTreatMedicationID(id))
	return &TreatMedicationUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for TreatMedication.
func (c *TreatMedicationClient) Delete() *TreatMedicationDelete {
	mutation := newTreatMedicationMutation(c.config, OpDelete)
	return &TreatMedicationDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *TreatMedicationClient) DeleteOne(tm *TreatMedication) *TreatMedicationDeleteOne {
	return c.DeleteOneID(tm.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *TreatMedicationClient) DeleteOneID(id int) *TreatMedicationDeleteOne {
	builder := c.Delete().Where(treatmedication.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &TreatMedicationDeleteOne{builder}
}

// Query returns a query builder for TreatMedication.
func (c *TreatMedicationClient) Query() *TreatMedicationQuery {
	return &TreatMedicationQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeTreatMedication},
		inters: c.Interceptors(),
	}
}

// Get returns a TreatMedication entity by its id.
func (c *TreatMedicationClient) Get(ctx context.Context, id int) (*TreatMedication, error) {
	return c.Query().Where(treatmedication.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *TreatMedicationClient) GetX(ctx context.Context, id int) *TreatMedication {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// Hooks returns the client hooks.
func (c *TreatMedicationClient) Hooks() []Hook {
	return c.hooks.TreatMedication
}

// Interceptors returns the client interceptors.
func (c *TreatMedicationClient) Interceptors() []Interceptor {
	return c.inters.TreatMedication
}

func (c *TreatMedicationClient) mutate(ctx context.Context, m *TreatMedicationMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&TreatMedicationCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&TreatMedicationUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&TreatMedicationUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&TreatMedicationDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown TreatMedication mutation op: %q", m.Op())
	}
}

// hooks and interceptors per client, for fast access.
type (
	hooks struct {
		ExamineDetail, ExamineMedication, Inpatient, InpatientDetail, Invoice,
		Medication, MedicationEffect, Outpatient, OutpatientDetail, Patient,
		TreatDetail, TreatMedication []ent.Hook
	}
	inters struct {
		ExamineDetail, ExamineMedication, Inpatient, InpatientDetail, Invoice,
		Medication, MedicationEffect, Outpatient, OutpatientDetail, Patient,
		TreatDetail, TreatMedication []ent.Interceptor
	}
)
