// Code generated by ent, DO NOT EDIT.

package ent

import (
	"context"
	"errors"
	"fmt"
	"patient/ent/medicalhistories"
	"patient/ent/medicalprescription"
	"patient/ent/medicalsurgery"
	"patient/ent/medicaltreatment"
	"patient/ent/medication"
	"patient/ent/patient"
	"patient/ent/predicate"
	"patient/ent/prescriptionmedication"
	"sync"
	"time"

	"entgo.io/ent"
	"entgo.io/ent/dialect/sql"
	"github.com/google/uuid"
)

const (
	// Operation types.
	OpCreate    = ent.OpCreate
	OpDelete    = ent.OpDelete
	OpDeleteOne = ent.OpDeleteOne
	OpUpdate    = ent.OpUpdate
	OpUpdateOne = ent.OpUpdateOne

	// Node types.
	TypeMedicalHistories       = "MedicalHistories"
	TypeMedicalPrescription    = "MedicalPrescription"
	TypeMedicalSurgery         = "MedicalSurgery"
	TypeMedicalTreatment       = "MedicalTreatment"
	TypeMedication             = "Medication"
	TypePatient                = "Patient"
	TypePrescriptionMedication = "PrescriptionMedication"
)

// MedicalHistoriesMutation represents an operation that mutates the MedicalHistories nodes in the graph.
type MedicalHistoriesMutation struct {
	config
	op                          Op
	typ                         string
	id                          *uuid.UUID
	reason                      *string
	diagnosis                   *string
	has_treatment               *bool
	has_surgery                 *bool
	has_prescription            *bool
	doctor_notes                *string
	medical_end_date            *time.Time
	created_at                  *time.Time
	updated_at                  *time.Time
	created_by                  *uuid.UUID
	updated_by                  *uuid.UUID
	clearedFields               map[string]struct{}
	patient                     *uuid.UUID
	clearedpatient              bool
	medical_prescription        map[uuid.UUID]struct{}
	removedmedical_prescription map[uuid.UUID]struct{}
	clearedmedical_prescription bool
	medical_treatment           map[uuid.UUID]struct{}
	removedmedical_treatment    map[uuid.UUID]struct{}
	clearedmedical_treatment    bool
	medical_surgery             map[uuid.UUID]struct{}
	removedmedical_surgery      map[uuid.UUID]struct{}
	clearedmedical_surgery      bool
	done                        bool
	oldValue                    func(context.Context) (*MedicalHistories, error)
	predicates                  []predicate.MedicalHistories
}

var _ ent.Mutation = (*MedicalHistoriesMutation)(nil)

// medicalhistoriesOption allows management of the mutation configuration using functional options.
type medicalhistoriesOption func(*MedicalHistoriesMutation)

// newMedicalHistoriesMutation creates new mutation for the MedicalHistories entity.
func newMedicalHistoriesMutation(c config, op Op, opts ...medicalhistoriesOption) *MedicalHistoriesMutation {
	m := &MedicalHistoriesMutation{
		config:        c,
		op:            op,
		typ:           TypeMedicalHistories,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withMedicalHistoriesID sets the ID field of the mutation.
func withMedicalHistoriesID(id uuid.UUID) medicalhistoriesOption {
	return func(m *MedicalHistoriesMutation) {
		var (
			err   error
			once  sync.Once
			value *MedicalHistories
		)
		m.oldValue = func(ctx context.Context) (*MedicalHistories, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().MedicalHistories.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withMedicalHistories sets the old MedicalHistories of the mutation.
func withMedicalHistories(node *MedicalHistories) medicalhistoriesOption {
	return func(m *MedicalHistoriesMutation) {
		m.oldValue = func(context.Context) (*MedicalHistories, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m MedicalHistoriesMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m MedicalHistoriesMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of MedicalHistories entities.
func (m *MedicalHistoriesMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *MedicalHistoriesMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *MedicalHistoriesMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().MedicalHistories.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetPatientID sets the "patient_id" field.
func (m *MedicalHistoriesMutation) SetPatientID(u uuid.UUID) {
	m.patient = &u
}

// PatientID returns the value of the "patient_id" field in the mutation.
func (m *MedicalHistoriesMutation) PatientID() (r uuid.UUID, exists bool) {
	v := m.patient
	if v == nil {
		return
	}
	return *v, true
}

// OldPatientID returns the old "patient_id" field's value of the MedicalHistories entity.
// If the MedicalHistories object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MedicalHistoriesMutation) OldPatientID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPatientID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPatientID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPatientID: %w", err)
	}
	return oldValue.PatientID, nil
}

// ResetPatientID resets all changes to the "patient_id" field.
func (m *MedicalHistoriesMutation) ResetPatientID() {
	m.patient = nil
}

// SetReason sets the "reason" field.
func (m *MedicalHistoriesMutation) SetReason(s string) {
	m.reason = &s
}

// Reason returns the value of the "reason" field in the mutation.
func (m *MedicalHistoriesMutation) Reason() (r string, exists bool) {
	v := m.reason
	if v == nil {
		return
	}
	return *v, true
}

// OldReason returns the old "reason" field's value of the MedicalHistories entity.
// If the MedicalHistories object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MedicalHistoriesMutation) OldReason(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldReason is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldReason requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldReason: %w", err)
	}
	return oldValue.Reason, nil
}

// ResetReason resets all changes to the "reason" field.
func (m *MedicalHistoriesMutation) ResetReason() {
	m.reason = nil
}

// SetDiagnosis sets the "diagnosis" field.
func (m *MedicalHistoriesMutation) SetDiagnosis(s string) {
	m.diagnosis = &s
}

// Diagnosis returns the value of the "diagnosis" field in the mutation.
func (m *MedicalHistoriesMutation) Diagnosis() (r string, exists bool) {
	v := m.diagnosis
	if v == nil {
		return
	}
	return *v, true
}

// OldDiagnosis returns the old "diagnosis" field's value of the MedicalHistories entity.
// If the MedicalHistories object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MedicalHistoriesMutation) OldDiagnosis(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDiagnosis is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDiagnosis requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDiagnosis: %w", err)
	}
	return oldValue.Diagnosis, nil
}

// ResetDiagnosis resets all changes to the "diagnosis" field.
func (m *MedicalHistoriesMutation) ResetDiagnosis() {
	m.diagnosis = nil
}

// SetHasTreatment sets the "has_treatment" field.
func (m *MedicalHistoriesMutation) SetHasTreatment(b bool) {
	m.has_treatment = &b
}

// HasTreatment returns the value of the "has_treatment" field in the mutation.
func (m *MedicalHistoriesMutation) HasTreatment() (r bool, exists bool) {
	v := m.has_treatment
	if v == nil {
		return
	}
	return *v, true
}

// OldHasTreatment returns the old "has_treatment" field's value of the MedicalHistories entity.
// If the MedicalHistories object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MedicalHistoriesMutation) OldHasTreatment(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldHasTreatment is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldHasTreatment requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldHasTreatment: %w", err)
	}
	return oldValue.HasTreatment, nil
}

// ResetHasTreatment resets all changes to the "has_treatment" field.
func (m *MedicalHistoriesMutation) ResetHasTreatment() {
	m.has_treatment = nil
}

// SetHasSurgery sets the "has_surgery" field.
func (m *MedicalHistoriesMutation) SetHasSurgery(b bool) {
	m.has_surgery = &b
}

// HasSurgery returns the value of the "has_surgery" field in the mutation.
func (m *MedicalHistoriesMutation) HasSurgery() (r bool, exists bool) {
	v := m.has_surgery
	if v == nil {
		return
	}
	return *v, true
}

// OldHasSurgery returns the old "has_surgery" field's value of the MedicalHistories entity.
// If the MedicalHistories object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MedicalHistoriesMutation) OldHasSurgery(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldHasSurgery is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldHasSurgery requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldHasSurgery: %w", err)
	}
	return oldValue.HasSurgery, nil
}

// ResetHasSurgery resets all changes to the "has_surgery" field.
func (m *MedicalHistoriesMutation) ResetHasSurgery() {
	m.has_surgery = nil
}

// SetHasPrescription sets the "has_prescription" field.
func (m *MedicalHistoriesMutation) SetHasPrescription(b bool) {
	m.has_prescription = &b
}

// HasPrescription returns the value of the "has_prescription" field in the mutation.
func (m *MedicalHistoriesMutation) HasPrescription() (r bool, exists bool) {
	v := m.has_prescription
	if v == nil {
		return
	}
	return *v, true
}

// OldHasPrescription returns the old "has_prescription" field's value of the MedicalHistories entity.
// If the MedicalHistories object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MedicalHistoriesMutation) OldHasPrescription(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldHasPrescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldHasPrescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldHasPrescription: %w", err)
	}
	return oldValue.HasPrescription, nil
}

// ResetHasPrescription resets all changes to the "has_prescription" field.
func (m *MedicalHistoriesMutation) ResetHasPrescription() {
	m.has_prescription = nil
}

// SetDoctorNotes sets the "doctor_notes" field.
func (m *MedicalHistoriesMutation) SetDoctorNotes(s string) {
	m.doctor_notes = &s
}

// DoctorNotes returns the value of the "doctor_notes" field in the mutation.
func (m *MedicalHistoriesMutation) DoctorNotes() (r string, exists bool) {
	v := m.doctor_notes
	if v == nil {
		return
	}
	return *v, true
}

// OldDoctorNotes returns the old "doctor_notes" field's value of the MedicalHistories entity.
// If the MedicalHistories object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MedicalHistoriesMutation) OldDoctorNotes(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDoctorNotes is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDoctorNotes requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDoctorNotes: %w", err)
	}
	return oldValue.DoctorNotes, nil
}

// ClearDoctorNotes clears the value of the "doctor_notes" field.
func (m *MedicalHistoriesMutation) ClearDoctorNotes() {
	m.doctor_notes = nil
	m.clearedFields[medicalhistories.FieldDoctorNotes] = struct{}{}
}

// DoctorNotesCleared returns if the "doctor_notes" field was cleared in this mutation.
func (m *MedicalHistoriesMutation) DoctorNotesCleared() bool {
	_, ok := m.clearedFields[medicalhistories.FieldDoctorNotes]
	return ok
}

// ResetDoctorNotes resets all changes to the "doctor_notes" field.
func (m *MedicalHistoriesMutation) ResetDoctorNotes() {
	m.doctor_notes = nil
	delete(m.clearedFields, medicalhistories.FieldDoctorNotes)
}

// SetMedicalEndDate sets the "medical_end_date" field.
func (m *MedicalHistoriesMutation) SetMedicalEndDate(t time.Time) {
	m.medical_end_date = &t
}

// MedicalEndDate returns the value of the "medical_end_date" field in the mutation.
func (m *MedicalHistoriesMutation) MedicalEndDate() (r time.Time, exists bool) {
	v := m.medical_end_date
	if v == nil {
		return
	}
	return *v, true
}

// OldMedicalEndDate returns the old "medical_end_date" field's value of the MedicalHistories entity.
// If the MedicalHistories object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MedicalHistoriesMutation) OldMedicalEndDate(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMedicalEndDate is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMedicalEndDate requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMedicalEndDate: %w", err)
	}
	return oldValue.MedicalEndDate, nil
}

// ClearMedicalEndDate clears the value of the "medical_end_date" field.
func (m *MedicalHistoriesMutation) ClearMedicalEndDate() {
	m.medical_end_date = nil
	m.clearedFields[medicalhistories.FieldMedicalEndDate] = struct{}{}
}

// MedicalEndDateCleared returns if the "medical_end_date" field was cleared in this mutation.
func (m *MedicalHistoriesMutation) MedicalEndDateCleared() bool {
	_, ok := m.clearedFields[medicalhistories.FieldMedicalEndDate]
	return ok
}

// ResetMedicalEndDate resets all changes to the "medical_end_date" field.
func (m *MedicalHistoriesMutation) ResetMedicalEndDate() {
	m.medical_end_date = nil
	delete(m.clearedFields, medicalhistories.FieldMedicalEndDate)
}

// SetCreatedAt sets the "created_at" field.
func (m *MedicalHistoriesMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *MedicalHistoriesMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the MedicalHistories entity.
// If the MedicalHistories object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MedicalHistoriesMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *MedicalHistoriesMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *MedicalHistoriesMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *MedicalHistoriesMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the MedicalHistories entity.
// If the MedicalHistories object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MedicalHistoriesMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *MedicalHistoriesMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetCreatedBy sets the "created_by" field.
func (m *MedicalHistoriesMutation) SetCreatedBy(u uuid.UUID) {
	m.created_by = &u
}

// CreatedBy returns the value of the "created_by" field in the mutation.
func (m *MedicalHistoriesMutation) CreatedBy() (r uuid.UUID, exists bool) {
	v := m.created_by
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedBy returns the old "created_by" field's value of the MedicalHistories entity.
// If the MedicalHistories object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MedicalHistoriesMutation) OldCreatedBy(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedBy: %w", err)
	}
	return oldValue.CreatedBy, nil
}

// ResetCreatedBy resets all changes to the "created_by" field.
func (m *MedicalHistoriesMutation) ResetCreatedBy() {
	m.created_by = nil
}

// SetUpdatedBy sets the "updated_by" field.
func (m *MedicalHistoriesMutation) SetUpdatedBy(u uuid.UUID) {
	m.updated_by = &u
}

// UpdatedBy returns the value of the "updated_by" field in the mutation.
func (m *MedicalHistoriesMutation) UpdatedBy() (r uuid.UUID, exists bool) {
	v := m.updated_by
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedBy returns the old "updated_by" field's value of the MedicalHistories entity.
// If the MedicalHistories object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MedicalHistoriesMutation) OldUpdatedBy(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedBy: %w", err)
	}
	return oldValue.UpdatedBy, nil
}

// ResetUpdatedBy resets all changes to the "updated_by" field.
func (m *MedicalHistoriesMutation) ResetUpdatedBy() {
	m.updated_by = nil
}

// ClearPatient clears the "patient" edge to the Patient entity.
func (m *MedicalHistoriesMutation) ClearPatient() {
	m.clearedpatient = true
	m.clearedFields[medicalhistories.FieldPatientID] = struct{}{}
}

// PatientCleared reports if the "patient" edge to the Patient entity was cleared.
func (m *MedicalHistoriesMutation) PatientCleared() bool {
	return m.clearedpatient
}

// PatientIDs returns the "patient" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// PatientID instead. It exists only for internal usage by the builders.
func (m *MedicalHistoriesMutation) PatientIDs() (ids []uuid.UUID) {
	if id := m.patient; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetPatient resets all changes to the "patient" edge.
func (m *MedicalHistoriesMutation) ResetPatient() {
	m.patient = nil
	m.clearedpatient = false
}

// AddMedicalPrescriptionIDs adds the "medical_prescription" edge to the MedicalPrescription entity by ids.
func (m *MedicalHistoriesMutation) AddMedicalPrescriptionIDs(ids ...uuid.UUID) {
	if m.medical_prescription == nil {
		m.medical_prescription = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.medical_prescription[ids[i]] = struct{}{}
	}
}

// ClearMedicalPrescription clears the "medical_prescription" edge to the MedicalPrescription entity.
func (m *MedicalHistoriesMutation) ClearMedicalPrescription() {
	m.clearedmedical_prescription = true
}

// MedicalPrescriptionCleared reports if the "medical_prescription" edge to the MedicalPrescription entity was cleared.
func (m *MedicalHistoriesMutation) MedicalPrescriptionCleared() bool {
	return m.clearedmedical_prescription
}

// RemoveMedicalPrescriptionIDs removes the "medical_prescription" edge to the MedicalPrescription entity by IDs.
func (m *MedicalHistoriesMutation) RemoveMedicalPrescriptionIDs(ids ...uuid.UUID) {
	if m.removedmedical_prescription == nil {
		m.removedmedical_prescription = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.medical_prescription, ids[i])
		m.removedmedical_prescription[ids[i]] = struct{}{}
	}
}

// RemovedMedicalPrescription returns the removed IDs of the "medical_prescription" edge to the MedicalPrescription entity.
func (m *MedicalHistoriesMutation) RemovedMedicalPrescriptionIDs() (ids []uuid.UUID) {
	for id := range m.removedmedical_prescription {
		ids = append(ids, id)
	}
	return
}

// MedicalPrescriptionIDs returns the "medical_prescription" edge IDs in the mutation.
func (m *MedicalHistoriesMutation) MedicalPrescriptionIDs() (ids []uuid.UUID) {
	for id := range m.medical_prescription {
		ids = append(ids, id)
	}
	return
}

// ResetMedicalPrescription resets all changes to the "medical_prescription" edge.
func (m *MedicalHistoriesMutation) ResetMedicalPrescription() {
	m.medical_prescription = nil
	m.clearedmedical_prescription = false
	m.removedmedical_prescription = nil
}

// AddMedicalTreatmentIDs adds the "medical_treatment" edge to the MedicalTreatment entity by ids.
func (m *MedicalHistoriesMutation) AddMedicalTreatmentIDs(ids ...uuid.UUID) {
	if m.medical_treatment == nil {
		m.medical_treatment = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.medical_treatment[ids[i]] = struct{}{}
	}
}

// ClearMedicalTreatment clears the "medical_treatment" edge to the MedicalTreatment entity.
func (m *MedicalHistoriesMutation) ClearMedicalTreatment() {
	m.clearedmedical_treatment = true
}

// MedicalTreatmentCleared reports if the "medical_treatment" edge to the MedicalTreatment entity was cleared.
func (m *MedicalHistoriesMutation) MedicalTreatmentCleared() bool {
	return m.clearedmedical_treatment
}

// RemoveMedicalTreatmentIDs removes the "medical_treatment" edge to the MedicalTreatment entity by IDs.
func (m *MedicalHistoriesMutation) RemoveMedicalTreatmentIDs(ids ...uuid.UUID) {
	if m.removedmedical_treatment == nil {
		m.removedmedical_treatment = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.medical_treatment, ids[i])
		m.removedmedical_treatment[ids[i]] = struct{}{}
	}
}

// RemovedMedicalTreatment returns the removed IDs of the "medical_treatment" edge to the MedicalTreatment entity.
func (m *MedicalHistoriesMutation) RemovedMedicalTreatmentIDs() (ids []uuid.UUID) {
	for id := range m.removedmedical_treatment {
		ids = append(ids, id)
	}
	return
}

// MedicalTreatmentIDs returns the "medical_treatment" edge IDs in the mutation.
func (m *MedicalHistoriesMutation) MedicalTreatmentIDs() (ids []uuid.UUID) {
	for id := range m.medical_treatment {
		ids = append(ids, id)
	}
	return
}

// ResetMedicalTreatment resets all changes to the "medical_treatment" edge.
func (m *MedicalHistoriesMutation) ResetMedicalTreatment() {
	m.medical_treatment = nil
	m.clearedmedical_treatment = false
	m.removedmedical_treatment = nil
}

// AddMedicalSurgeryIDs adds the "medical_surgery" edge to the MedicalSurgery entity by ids.
func (m *MedicalHistoriesMutation) AddMedicalSurgeryIDs(ids ...uuid.UUID) {
	if m.medical_surgery == nil {
		m.medical_surgery = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.medical_surgery[ids[i]] = struct{}{}
	}
}

// ClearMedicalSurgery clears the "medical_surgery" edge to the MedicalSurgery entity.
func (m *MedicalHistoriesMutation) ClearMedicalSurgery() {
	m.clearedmedical_surgery = true
}

// MedicalSurgeryCleared reports if the "medical_surgery" edge to the MedicalSurgery entity was cleared.
func (m *MedicalHistoriesMutation) MedicalSurgeryCleared() bool {
	return m.clearedmedical_surgery
}

// RemoveMedicalSurgeryIDs removes the "medical_surgery" edge to the MedicalSurgery entity by IDs.
func (m *MedicalHistoriesMutation) RemoveMedicalSurgeryIDs(ids ...uuid.UUID) {
	if m.removedmedical_surgery == nil {
		m.removedmedical_surgery = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.medical_surgery, ids[i])
		m.removedmedical_surgery[ids[i]] = struct{}{}
	}
}

// RemovedMedicalSurgery returns the removed IDs of the "medical_surgery" edge to the MedicalSurgery entity.
func (m *MedicalHistoriesMutation) RemovedMedicalSurgeryIDs() (ids []uuid.UUID) {
	for id := range m.removedmedical_surgery {
		ids = append(ids, id)
	}
	return
}

// MedicalSurgeryIDs returns the "medical_surgery" edge IDs in the mutation.
func (m *MedicalHistoriesMutation) MedicalSurgeryIDs() (ids []uuid.UUID) {
	for id := range m.medical_surgery {
		ids = append(ids, id)
	}
	return
}

// ResetMedicalSurgery resets all changes to the "medical_surgery" edge.
func (m *MedicalHistoriesMutation) ResetMedicalSurgery() {
	m.medical_surgery = nil
	m.clearedmedical_surgery = false
	m.removedmedical_surgery = nil
}

// Where appends a list predicates to the MedicalHistoriesMutation builder.
func (m *MedicalHistoriesMutation) Where(ps ...predicate.MedicalHistories) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the MedicalHistoriesMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *MedicalHistoriesMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.MedicalHistories, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *MedicalHistoriesMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *MedicalHistoriesMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (MedicalHistories).
func (m *MedicalHistoriesMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *MedicalHistoriesMutation) Fields() []string {
	fields := make([]string, 0, 12)
	if m.patient != nil {
		fields = append(fields, medicalhistories.FieldPatientID)
	}
	if m.reason != nil {
		fields = append(fields, medicalhistories.FieldReason)
	}
	if m.diagnosis != nil {
		fields = append(fields, medicalhistories.FieldDiagnosis)
	}
	if m.has_treatment != nil {
		fields = append(fields, medicalhistories.FieldHasTreatment)
	}
	if m.has_surgery != nil {
		fields = append(fields, medicalhistories.FieldHasSurgery)
	}
	if m.has_prescription != nil {
		fields = append(fields, medicalhistories.FieldHasPrescription)
	}
	if m.doctor_notes != nil {
		fields = append(fields, medicalhistories.FieldDoctorNotes)
	}
	if m.medical_end_date != nil {
		fields = append(fields, medicalhistories.FieldMedicalEndDate)
	}
	if m.created_at != nil {
		fields = append(fields, medicalhistories.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, medicalhistories.FieldUpdatedAt)
	}
	if m.created_by != nil {
		fields = append(fields, medicalhistories.FieldCreatedBy)
	}
	if m.updated_by != nil {
		fields = append(fields, medicalhistories.FieldUpdatedBy)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *MedicalHistoriesMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case medicalhistories.FieldPatientID:
		return m.PatientID()
	case medicalhistories.FieldReason:
		return m.Reason()
	case medicalhistories.FieldDiagnosis:
		return m.Diagnosis()
	case medicalhistories.FieldHasTreatment:
		return m.HasTreatment()
	case medicalhistories.FieldHasSurgery:
		return m.HasSurgery()
	case medicalhistories.FieldHasPrescription:
		return m.HasPrescription()
	case medicalhistories.FieldDoctorNotes:
		return m.DoctorNotes()
	case medicalhistories.FieldMedicalEndDate:
		return m.MedicalEndDate()
	case medicalhistories.FieldCreatedAt:
		return m.CreatedAt()
	case medicalhistories.FieldUpdatedAt:
		return m.UpdatedAt()
	case medicalhistories.FieldCreatedBy:
		return m.CreatedBy()
	case medicalhistories.FieldUpdatedBy:
		return m.UpdatedBy()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *MedicalHistoriesMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case medicalhistories.FieldPatientID:
		return m.OldPatientID(ctx)
	case medicalhistories.FieldReason:
		return m.OldReason(ctx)
	case medicalhistories.FieldDiagnosis:
		return m.OldDiagnosis(ctx)
	case medicalhistories.FieldHasTreatment:
		return m.OldHasTreatment(ctx)
	case medicalhistories.FieldHasSurgery:
		return m.OldHasSurgery(ctx)
	case medicalhistories.FieldHasPrescription:
		return m.OldHasPrescription(ctx)
	case medicalhistories.FieldDoctorNotes:
		return m.OldDoctorNotes(ctx)
	case medicalhistories.FieldMedicalEndDate:
		return m.OldMedicalEndDate(ctx)
	case medicalhistories.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case medicalhistories.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case medicalhistories.FieldCreatedBy:
		return m.OldCreatedBy(ctx)
	case medicalhistories.FieldUpdatedBy:
		return m.OldUpdatedBy(ctx)
	}
	return nil, fmt.Errorf("unknown MedicalHistories field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *MedicalHistoriesMutation) SetField(name string, value ent.Value) error {
	switch name {
	case medicalhistories.FieldPatientID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPatientID(v)
		return nil
	case medicalhistories.FieldReason:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetReason(v)
		return nil
	case medicalhistories.FieldDiagnosis:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDiagnosis(v)
		return nil
	case medicalhistories.FieldHasTreatment:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetHasTreatment(v)
		return nil
	case medicalhistories.FieldHasSurgery:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetHasSurgery(v)
		return nil
	case medicalhistories.FieldHasPrescription:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetHasPrescription(v)
		return nil
	case medicalhistories.FieldDoctorNotes:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDoctorNotes(v)
		return nil
	case medicalhistories.FieldMedicalEndDate:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMedicalEndDate(v)
		return nil
	case medicalhistories.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case medicalhistories.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case medicalhistories.FieldCreatedBy:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedBy(v)
		return nil
	case medicalhistories.FieldUpdatedBy:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedBy(v)
		return nil
	}
	return fmt.Errorf("unknown MedicalHistories field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *MedicalHistoriesMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *MedicalHistoriesMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *MedicalHistoriesMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown MedicalHistories numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *MedicalHistoriesMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(medicalhistories.FieldDoctorNotes) {
		fields = append(fields, medicalhistories.FieldDoctorNotes)
	}
	if m.FieldCleared(medicalhistories.FieldMedicalEndDate) {
		fields = append(fields, medicalhistories.FieldMedicalEndDate)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *MedicalHistoriesMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *MedicalHistoriesMutation) ClearField(name string) error {
	switch name {
	case medicalhistories.FieldDoctorNotes:
		m.ClearDoctorNotes()
		return nil
	case medicalhistories.FieldMedicalEndDate:
		m.ClearMedicalEndDate()
		return nil
	}
	return fmt.Errorf("unknown MedicalHistories nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *MedicalHistoriesMutation) ResetField(name string) error {
	switch name {
	case medicalhistories.FieldPatientID:
		m.ResetPatientID()
		return nil
	case medicalhistories.FieldReason:
		m.ResetReason()
		return nil
	case medicalhistories.FieldDiagnosis:
		m.ResetDiagnosis()
		return nil
	case medicalhistories.FieldHasTreatment:
		m.ResetHasTreatment()
		return nil
	case medicalhistories.FieldHasSurgery:
		m.ResetHasSurgery()
		return nil
	case medicalhistories.FieldHasPrescription:
		m.ResetHasPrescription()
		return nil
	case medicalhistories.FieldDoctorNotes:
		m.ResetDoctorNotes()
		return nil
	case medicalhistories.FieldMedicalEndDate:
		m.ResetMedicalEndDate()
		return nil
	case medicalhistories.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case medicalhistories.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case medicalhistories.FieldCreatedBy:
		m.ResetCreatedBy()
		return nil
	case medicalhistories.FieldUpdatedBy:
		m.ResetUpdatedBy()
		return nil
	}
	return fmt.Errorf("unknown MedicalHistories field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *MedicalHistoriesMutation) AddedEdges() []string {
	edges := make([]string, 0, 4)
	if m.patient != nil {
		edges = append(edges, medicalhistories.EdgePatient)
	}
	if m.medical_prescription != nil {
		edges = append(edges, medicalhistories.EdgeMedicalPrescription)
	}
	if m.medical_treatment != nil {
		edges = append(edges, medicalhistories.EdgeMedicalTreatment)
	}
	if m.medical_surgery != nil {
		edges = append(edges, medicalhistories.EdgeMedicalSurgery)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *MedicalHistoriesMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case medicalhistories.EdgePatient:
		if id := m.patient; id != nil {
			return []ent.Value{*id}
		}
	case medicalhistories.EdgeMedicalPrescription:
		ids := make([]ent.Value, 0, len(m.medical_prescription))
		for id := range m.medical_prescription {
			ids = append(ids, id)
		}
		return ids
	case medicalhistories.EdgeMedicalTreatment:
		ids := make([]ent.Value, 0, len(m.medical_treatment))
		for id := range m.medical_treatment {
			ids = append(ids, id)
		}
		return ids
	case medicalhistories.EdgeMedicalSurgery:
		ids := make([]ent.Value, 0, len(m.medical_surgery))
		for id := range m.medical_surgery {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *MedicalHistoriesMutation) RemovedEdges() []string {
	edges := make([]string, 0, 4)
	if m.removedmedical_prescription != nil {
		edges = append(edges, medicalhistories.EdgeMedicalPrescription)
	}
	if m.removedmedical_treatment != nil {
		edges = append(edges, medicalhistories.EdgeMedicalTreatment)
	}
	if m.removedmedical_surgery != nil {
		edges = append(edges, medicalhistories.EdgeMedicalSurgery)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *MedicalHistoriesMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case medicalhistories.EdgeMedicalPrescription:
		ids := make([]ent.Value, 0, len(m.removedmedical_prescription))
		for id := range m.removedmedical_prescription {
			ids = append(ids, id)
		}
		return ids
	case medicalhistories.EdgeMedicalTreatment:
		ids := make([]ent.Value, 0, len(m.removedmedical_treatment))
		for id := range m.removedmedical_treatment {
			ids = append(ids, id)
		}
		return ids
	case medicalhistories.EdgeMedicalSurgery:
		ids := make([]ent.Value, 0, len(m.removedmedical_surgery))
		for id := range m.removedmedical_surgery {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *MedicalHistoriesMutation) ClearedEdges() []string {
	edges := make([]string, 0, 4)
	if m.clearedpatient {
		edges = append(edges, medicalhistories.EdgePatient)
	}
	if m.clearedmedical_prescription {
		edges = append(edges, medicalhistories.EdgeMedicalPrescription)
	}
	if m.clearedmedical_treatment {
		edges = append(edges, medicalhistories.EdgeMedicalTreatment)
	}
	if m.clearedmedical_surgery {
		edges = append(edges, medicalhistories.EdgeMedicalSurgery)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *MedicalHistoriesMutation) EdgeCleared(name string) bool {
	switch name {
	case medicalhistories.EdgePatient:
		return m.clearedpatient
	case medicalhistories.EdgeMedicalPrescription:
		return m.clearedmedical_prescription
	case medicalhistories.EdgeMedicalTreatment:
		return m.clearedmedical_treatment
	case medicalhistories.EdgeMedicalSurgery:
		return m.clearedmedical_surgery
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *MedicalHistoriesMutation) ClearEdge(name string) error {
	switch name {
	case medicalhistories.EdgePatient:
		m.ClearPatient()
		return nil
	}
	return fmt.Errorf("unknown MedicalHistories unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *MedicalHistoriesMutation) ResetEdge(name string) error {
	switch name {
	case medicalhistories.EdgePatient:
		m.ResetPatient()
		return nil
	case medicalhistories.EdgeMedicalPrescription:
		m.ResetMedicalPrescription()
		return nil
	case medicalhistories.EdgeMedicalTreatment:
		m.ResetMedicalTreatment()
		return nil
	case medicalhistories.EdgeMedicalSurgery:
		m.ResetMedicalSurgery()
		return nil
	}
	return fmt.Errorf("unknown MedicalHistories edge %s", name)
}

// MedicalPrescriptionMutation represents an operation that mutates the MedicalPrescription nodes in the graph.
type MedicalPrescriptionMutation struct {
	config
	op                             Op
	typ                            string
	id                             *uuid.UUID
	prescription_date              *time.Time
	fee                            *float64
	addfee                         *float64
	created_at                     *time.Time
	created_by                     *uuid.UUID
	clearedFields                  map[string]struct{}
	medical_histories              *uuid.UUID
	clearedmedical_histories       bool
	prescription_medication        map[uuid.UUID]struct{}
	removedprescription_medication map[uuid.UUID]struct{}
	clearedprescription_medication bool
	done                           bool
	oldValue                       func(context.Context) (*MedicalPrescription, error)
	predicates                     []predicate.MedicalPrescription
}

var _ ent.Mutation = (*MedicalPrescriptionMutation)(nil)

// medicalprescriptionOption allows management of the mutation configuration using functional options.
type medicalprescriptionOption func(*MedicalPrescriptionMutation)

// newMedicalPrescriptionMutation creates new mutation for the MedicalPrescription entity.
func newMedicalPrescriptionMutation(c config, op Op, opts ...medicalprescriptionOption) *MedicalPrescriptionMutation {
	m := &MedicalPrescriptionMutation{
		config:        c,
		op:            op,
		typ:           TypeMedicalPrescription,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withMedicalPrescriptionID sets the ID field of the mutation.
func withMedicalPrescriptionID(id uuid.UUID) medicalprescriptionOption {
	return func(m *MedicalPrescriptionMutation) {
		var (
			err   error
			once  sync.Once
			value *MedicalPrescription
		)
		m.oldValue = func(ctx context.Context) (*MedicalPrescription, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().MedicalPrescription.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withMedicalPrescription sets the old MedicalPrescription of the mutation.
func withMedicalPrescription(node *MedicalPrescription) medicalprescriptionOption {
	return func(m *MedicalPrescriptionMutation) {
		m.oldValue = func(context.Context) (*MedicalPrescription, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m MedicalPrescriptionMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m MedicalPrescriptionMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of MedicalPrescription entities.
func (m *MedicalPrescriptionMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *MedicalPrescriptionMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *MedicalPrescriptionMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().MedicalPrescription.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetMedicalHistoryID sets the "medical_history_id" field.
func (m *MedicalPrescriptionMutation) SetMedicalHistoryID(u uuid.UUID) {
	m.medical_histories = &u
}

// MedicalHistoryID returns the value of the "medical_history_id" field in the mutation.
func (m *MedicalPrescriptionMutation) MedicalHistoryID() (r uuid.UUID, exists bool) {
	v := m.medical_histories
	if v == nil {
		return
	}
	return *v, true
}

// OldMedicalHistoryID returns the old "medical_history_id" field's value of the MedicalPrescription entity.
// If the MedicalPrescription object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MedicalPrescriptionMutation) OldMedicalHistoryID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMedicalHistoryID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMedicalHistoryID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMedicalHistoryID: %w", err)
	}
	return oldValue.MedicalHistoryID, nil
}

// ResetMedicalHistoryID resets all changes to the "medical_history_id" field.
func (m *MedicalPrescriptionMutation) ResetMedicalHistoryID() {
	m.medical_histories = nil
}

// SetPrescriptionDate sets the "prescription_date" field.
func (m *MedicalPrescriptionMutation) SetPrescriptionDate(t time.Time) {
	m.prescription_date = &t
}

// PrescriptionDate returns the value of the "prescription_date" field in the mutation.
func (m *MedicalPrescriptionMutation) PrescriptionDate() (r time.Time, exists bool) {
	v := m.prescription_date
	if v == nil {
		return
	}
	return *v, true
}

// OldPrescriptionDate returns the old "prescription_date" field's value of the MedicalPrescription entity.
// If the MedicalPrescription object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MedicalPrescriptionMutation) OldPrescriptionDate(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPrescriptionDate is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPrescriptionDate requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPrescriptionDate: %w", err)
	}
	return oldValue.PrescriptionDate, nil
}

// ResetPrescriptionDate resets all changes to the "prescription_date" field.
func (m *MedicalPrescriptionMutation) ResetPrescriptionDate() {
	m.prescription_date = nil
}

// SetFee sets the "fee" field.
func (m *MedicalPrescriptionMutation) SetFee(f float64) {
	m.fee = &f
	m.addfee = nil
}

// Fee returns the value of the "fee" field in the mutation.
func (m *MedicalPrescriptionMutation) Fee() (r float64, exists bool) {
	v := m.fee
	if v == nil {
		return
	}
	return *v, true
}

// OldFee returns the old "fee" field's value of the MedicalPrescription entity.
// If the MedicalPrescription object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MedicalPrescriptionMutation) OldFee(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFee is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFee requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFee: %w", err)
	}
	return oldValue.Fee, nil
}

// AddFee adds f to the "fee" field.
func (m *MedicalPrescriptionMutation) AddFee(f float64) {
	if m.addfee != nil {
		*m.addfee += f
	} else {
		m.addfee = &f
	}
}

// AddedFee returns the value that was added to the "fee" field in this mutation.
func (m *MedicalPrescriptionMutation) AddedFee() (r float64, exists bool) {
	v := m.addfee
	if v == nil {
		return
	}
	return *v, true
}

// ResetFee resets all changes to the "fee" field.
func (m *MedicalPrescriptionMutation) ResetFee() {
	m.fee = nil
	m.addfee = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *MedicalPrescriptionMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *MedicalPrescriptionMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the MedicalPrescription entity.
// If the MedicalPrescription object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MedicalPrescriptionMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *MedicalPrescriptionMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetCreatedBy sets the "created_by" field.
func (m *MedicalPrescriptionMutation) SetCreatedBy(u uuid.UUID) {
	m.created_by = &u
}

// CreatedBy returns the value of the "created_by" field in the mutation.
func (m *MedicalPrescriptionMutation) CreatedBy() (r uuid.UUID, exists bool) {
	v := m.created_by
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedBy returns the old "created_by" field's value of the MedicalPrescription entity.
// If the MedicalPrescription object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MedicalPrescriptionMutation) OldCreatedBy(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedBy: %w", err)
	}
	return oldValue.CreatedBy, nil
}

// ResetCreatedBy resets all changes to the "created_by" field.
func (m *MedicalPrescriptionMutation) ResetCreatedBy() {
	m.created_by = nil
}

// SetMedicalHistoriesID sets the "medical_histories" edge to the MedicalHistories entity by id.
func (m *MedicalPrescriptionMutation) SetMedicalHistoriesID(id uuid.UUID) {
	m.medical_histories = &id
}

// ClearMedicalHistories clears the "medical_histories" edge to the MedicalHistories entity.
func (m *MedicalPrescriptionMutation) ClearMedicalHistories() {
	m.clearedmedical_histories = true
	m.clearedFields[medicalprescription.FieldMedicalHistoryID] = struct{}{}
}

// MedicalHistoriesCleared reports if the "medical_histories" edge to the MedicalHistories entity was cleared.
func (m *MedicalPrescriptionMutation) MedicalHistoriesCleared() bool {
	return m.clearedmedical_histories
}

// MedicalHistoriesID returns the "medical_histories" edge ID in the mutation.
func (m *MedicalPrescriptionMutation) MedicalHistoriesID() (id uuid.UUID, exists bool) {
	if m.medical_histories != nil {
		return *m.medical_histories, true
	}
	return
}

// MedicalHistoriesIDs returns the "medical_histories" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// MedicalHistoriesID instead. It exists only for internal usage by the builders.
func (m *MedicalPrescriptionMutation) MedicalHistoriesIDs() (ids []uuid.UUID) {
	if id := m.medical_histories; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetMedicalHistories resets all changes to the "medical_histories" edge.
func (m *MedicalPrescriptionMutation) ResetMedicalHistories() {
	m.medical_histories = nil
	m.clearedmedical_histories = false
}

// AddPrescriptionMedicationIDs adds the "prescription_medication" edge to the PrescriptionMedication entity by ids.
func (m *MedicalPrescriptionMutation) AddPrescriptionMedicationIDs(ids ...uuid.UUID) {
	if m.prescription_medication == nil {
		m.prescription_medication = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.prescription_medication[ids[i]] = struct{}{}
	}
}

// ClearPrescriptionMedication clears the "prescription_medication" edge to the PrescriptionMedication entity.
func (m *MedicalPrescriptionMutation) ClearPrescriptionMedication() {
	m.clearedprescription_medication = true
}

// PrescriptionMedicationCleared reports if the "prescription_medication" edge to the PrescriptionMedication entity was cleared.
func (m *MedicalPrescriptionMutation) PrescriptionMedicationCleared() bool {
	return m.clearedprescription_medication
}

// RemovePrescriptionMedicationIDs removes the "prescription_medication" edge to the PrescriptionMedication entity by IDs.
func (m *MedicalPrescriptionMutation) RemovePrescriptionMedicationIDs(ids ...uuid.UUID) {
	if m.removedprescription_medication == nil {
		m.removedprescription_medication = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.prescription_medication, ids[i])
		m.removedprescription_medication[ids[i]] = struct{}{}
	}
}

// RemovedPrescriptionMedication returns the removed IDs of the "prescription_medication" edge to the PrescriptionMedication entity.
func (m *MedicalPrescriptionMutation) RemovedPrescriptionMedicationIDs() (ids []uuid.UUID) {
	for id := range m.removedprescription_medication {
		ids = append(ids, id)
	}
	return
}

// PrescriptionMedicationIDs returns the "prescription_medication" edge IDs in the mutation.
func (m *MedicalPrescriptionMutation) PrescriptionMedicationIDs() (ids []uuid.UUID) {
	for id := range m.prescription_medication {
		ids = append(ids, id)
	}
	return
}

// ResetPrescriptionMedication resets all changes to the "prescription_medication" edge.
func (m *MedicalPrescriptionMutation) ResetPrescriptionMedication() {
	m.prescription_medication = nil
	m.clearedprescription_medication = false
	m.removedprescription_medication = nil
}

// Where appends a list predicates to the MedicalPrescriptionMutation builder.
func (m *MedicalPrescriptionMutation) Where(ps ...predicate.MedicalPrescription) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the MedicalPrescriptionMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *MedicalPrescriptionMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.MedicalPrescription, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *MedicalPrescriptionMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *MedicalPrescriptionMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (MedicalPrescription).
func (m *MedicalPrescriptionMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *MedicalPrescriptionMutation) Fields() []string {
	fields := make([]string, 0, 5)
	if m.medical_histories != nil {
		fields = append(fields, medicalprescription.FieldMedicalHistoryID)
	}
	if m.prescription_date != nil {
		fields = append(fields, medicalprescription.FieldPrescriptionDate)
	}
	if m.fee != nil {
		fields = append(fields, medicalprescription.FieldFee)
	}
	if m.created_at != nil {
		fields = append(fields, medicalprescription.FieldCreatedAt)
	}
	if m.created_by != nil {
		fields = append(fields, medicalprescription.FieldCreatedBy)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *MedicalPrescriptionMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case medicalprescription.FieldMedicalHistoryID:
		return m.MedicalHistoryID()
	case medicalprescription.FieldPrescriptionDate:
		return m.PrescriptionDate()
	case medicalprescription.FieldFee:
		return m.Fee()
	case medicalprescription.FieldCreatedAt:
		return m.CreatedAt()
	case medicalprescription.FieldCreatedBy:
		return m.CreatedBy()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *MedicalPrescriptionMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case medicalprescription.FieldMedicalHistoryID:
		return m.OldMedicalHistoryID(ctx)
	case medicalprescription.FieldPrescriptionDate:
		return m.OldPrescriptionDate(ctx)
	case medicalprescription.FieldFee:
		return m.OldFee(ctx)
	case medicalprescription.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case medicalprescription.FieldCreatedBy:
		return m.OldCreatedBy(ctx)
	}
	return nil, fmt.Errorf("unknown MedicalPrescription field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *MedicalPrescriptionMutation) SetField(name string, value ent.Value) error {
	switch name {
	case medicalprescription.FieldMedicalHistoryID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMedicalHistoryID(v)
		return nil
	case medicalprescription.FieldPrescriptionDate:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPrescriptionDate(v)
		return nil
	case medicalprescription.FieldFee:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFee(v)
		return nil
	case medicalprescription.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case medicalprescription.FieldCreatedBy:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedBy(v)
		return nil
	}
	return fmt.Errorf("unknown MedicalPrescription field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *MedicalPrescriptionMutation) AddedFields() []string {
	var fields []string
	if m.addfee != nil {
		fields = append(fields, medicalprescription.FieldFee)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *MedicalPrescriptionMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case medicalprescription.FieldFee:
		return m.AddedFee()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *MedicalPrescriptionMutation) AddField(name string, value ent.Value) error {
	switch name {
	case medicalprescription.FieldFee:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddFee(v)
		return nil
	}
	return fmt.Errorf("unknown MedicalPrescription numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *MedicalPrescriptionMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *MedicalPrescriptionMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *MedicalPrescriptionMutation) ClearField(name string) error {
	return fmt.Errorf("unknown MedicalPrescription nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *MedicalPrescriptionMutation) ResetField(name string) error {
	switch name {
	case medicalprescription.FieldMedicalHistoryID:
		m.ResetMedicalHistoryID()
		return nil
	case medicalprescription.FieldPrescriptionDate:
		m.ResetPrescriptionDate()
		return nil
	case medicalprescription.FieldFee:
		m.ResetFee()
		return nil
	case medicalprescription.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case medicalprescription.FieldCreatedBy:
		m.ResetCreatedBy()
		return nil
	}
	return fmt.Errorf("unknown MedicalPrescription field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *MedicalPrescriptionMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.medical_histories != nil {
		edges = append(edges, medicalprescription.EdgeMedicalHistories)
	}
	if m.prescription_medication != nil {
		edges = append(edges, medicalprescription.EdgePrescriptionMedication)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *MedicalPrescriptionMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case medicalprescription.EdgeMedicalHistories:
		if id := m.medical_histories; id != nil {
			return []ent.Value{*id}
		}
	case medicalprescription.EdgePrescriptionMedication:
		ids := make([]ent.Value, 0, len(m.prescription_medication))
		for id := range m.prescription_medication {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *MedicalPrescriptionMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	if m.removedprescription_medication != nil {
		edges = append(edges, medicalprescription.EdgePrescriptionMedication)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *MedicalPrescriptionMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case medicalprescription.EdgePrescriptionMedication:
		ids := make([]ent.Value, 0, len(m.removedprescription_medication))
		for id := range m.removedprescription_medication {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *MedicalPrescriptionMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedmedical_histories {
		edges = append(edges, medicalprescription.EdgeMedicalHistories)
	}
	if m.clearedprescription_medication {
		edges = append(edges, medicalprescription.EdgePrescriptionMedication)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *MedicalPrescriptionMutation) EdgeCleared(name string) bool {
	switch name {
	case medicalprescription.EdgeMedicalHistories:
		return m.clearedmedical_histories
	case medicalprescription.EdgePrescriptionMedication:
		return m.clearedprescription_medication
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *MedicalPrescriptionMutation) ClearEdge(name string) error {
	switch name {
	case medicalprescription.EdgeMedicalHistories:
		m.ClearMedicalHistories()
		return nil
	}
	return fmt.Errorf("unknown MedicalPrescription unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *MedicalPrescriptionMutation) ResetEdge(name string) error {
	switch name {
	case medicalprescription.EdgeMedicalHistories:
		m.ResetMedicalHistories()
		return nil
	case medicalprescription.EdgePrescriptionMedication:
		m.ResetPrescriptionMedication()
		return nil
	}
	return fmt.Errorf("unknown MedicalPrescription edge %s", name)
}

// MedicalSurgeryMutation represents an operation that mutates the MedicalSurgery nodes in the graph.
type MedicalSurgeryMutation struct {
	config
	op                       Op
	typ                      string
	id                       *uuid.UUID
	start_date               *time.Time
	end_date                 *time.Time
	name                     *string
	result                   *string
	description              *string
	fee                      *float64
	addfee                   *float64
	main_doctor_id           *uuid.UUID
	support_doctor_ids       *string
	support_nurse_ids        *string
	created_at               *time.Time
	created_by               *uuid.UUID
	updated_by               *uuid.UUID
	updated_at               *time.Time
	clearedFields            map[string]struct{}
	medical_histories        *uuid.UUID
	clearedmedical_histories bool
	done                     bool
	oldValue                 func(context.Context) (*MedicalSurgery, error)
	predicates               []predicate.MedicalSurgery
}

var _ ent.Mutation = (*MedicalSurgeryMutation)(nil)

// medicalsurgeryOption allows management of the mutation configuration using functional options.
type medicalsurgeryOption func(*MedicalSurgeryMutation)

// newMedicalSurgeryMutation creates new mutation for the MedicalSurgery entity.
func newMedicalSurgeryMutation(c config, op Op, opts ...medicalsurgeryOption) *MedicalSurgeryMutation {
	m := &MedicalSurgeryMutation{
		config:        c,
		op:            op,
		typ:           TypeMedicalSurgery,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withMedicalSurgeryID sets the ID field of the mutation.
func withMedicalSurgeryID(id uuid.UUID) medicalsurgeryOption {
	return func(m *MedicalSurgeryMutation) {
		var (
			err   error
			once  sync.Once
			value *MedicalSurgery
		)
		m.oldValue = func(ctx context.Context) (*MedicalSurgery, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().MedicalSurgery.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withMedicalSurgery sets the old MedicalSurgery of the mutation.
func withMedicalSurgery(node *MedicalSurgery) medicalsurgeryOption {
	return func(m *MedicalSurgeryMutation) {
		m.oldValue = func(context.Context) (*MedicalSurgery, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m MedicalSurgeryMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m MedicalSurgeryMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of MedicalSurgery entities.
func (m *MedicalSurgeryMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *MedicalSurgeryMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *MedicalSurgeryMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().MedicalSurgery.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetMedicalHistoryID sets the "medical_history_id" field.
func (m *MedicalSurgeryMutation) SetMedicalHistoryID(u uuid.UUID) {
	m.medical_histories = &u
}

// MedicalHistoryID returns the value of the "medical_history_id" field in the mutation.
func (m *MedicalSurgeryMutation) MedicalHistoryID() (r uuid.UUID, exists bool) {
	v := m.medical_histories
	if v == nil {
		return
	}
	return *v, true
}

// OldMedicalHistoryID returns the old "medical_history_id" field's value of the MedicalSurgery entity.
// If the MedicalSurgery object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MedicalSurgeryMutation) OldMedicalHistoryID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMedicalHistoryID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMedicalHistoryID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMedicalHistoryID: %w", err)
	}
	return oldValue.MedicalHistoryID, nil
}

// ResetMedicalHistoryID resets all changes to the "medical_history_id" field.
func (m *MedicalSurgeryMutation) ResetMedicalHistoryID() {
	m.medical_histories = nil
}

// SetStartDate sets the "start_date" field.
func (m *MedicalSurgeryMutation) SetStartDate(t time.Time) {
	m.start_date = &t
}

// StartDate returns the value of the "start_date" field in the mutation.
func (m *MedicalSurgeryMutation) StartDate() (r time.Time, exists bool) {
	v := m.start_date
	if v == nil {
		return
	}
	return *v, true
}

// OldStartDate returns the old "start_date" field's value of the MedicalSurgery entity.
// If the MedicalSurgery object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MedicalSurgeryMutation) OldStartDate(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStartDate is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStartDate requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStartDate: %w", err)
	}
	return oldValue.StartDate, nil
}

// ResetStartDate resets all changes to the "start_date" field.
func (m *MedicalSurgeryMutation) ResetStartDate() {
	m.start_date = nil
}

// SetEndDate sets the "end_date" field.
func (m *MedicalSurgeryMutation) SetEndDate(t time.Time) {
	m.end_date = &t
}

// EndDate returns the value of the "end_date" field in the mutation.
func (m *MedicalSurgeryMutation) EndDate() (r time.Time, exists bool) {
	v := m.end_date
	if v == nil {
		return
	}
	return *v, true
}

// OldEndDate returns the old "end_date" field's value of the MedicalSurgery entity.
// If the MedicalSurgery object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MedicalSurgeryMutation) OldEndDate(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEndDate is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEndDate requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEndDate: %w", err)
	}
	return oldValue.EndDate, nil
}

// ResetEndDate resets all changes to the "end_date" field.
func (m *MedicalSurgeryMutation) ResetEndDate() {
	m.end_date = nil
}

// SetName sets the "name" field.
func (m *MedicalSurgeryMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *MedicalSurgeryMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the MedicalSurgery entity.
// If the MedicalSurgery object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MedicalSurgeryMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *MedicalSurgeryMutation) ResetName() {
	m.name = nil
}

// SetResult sets the "result" field.
func (m *MedicalSurgeryMutation) SetResult(s string) {
	m.result = &s
}

// Result returns the value of the "result" field in the mutation.
func (m *MedicalSurgeryMutation) Result() (r string, exists bool) {
	v := m.result
	if v == nil {
		return
	}
	return *v, true
}

// OldResult returns the old "result" field's value of the MedicalSurgery entity.
// If the MedicalSurgery object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MedicalSurgeryMutation) OldResult(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldResult is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldResult requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldResult: %w", err)
	}
	return oldValue.Result, nil
}

// ResetResult resets all changes to the "result" field.
func (m *MedicalSurgeryMutation) ResetResult() {
	m.result = nil
}

// SetDescription sets the "description" field.
func (m *MedicalSurgeryMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *MedicalSurgeryMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the MedicalSurgery entity.
// If the MedicalSurgery object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MedicalSurgeryMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ResetDescription resets all changes to the "description" field.
func (m *MedicalSurgeryMutation) ResetDescription() {
	m.description = nil
}

// SetFee sets the "fee" field.
func (m *MedicalSurgeryMutation) SetFee(f float64) {
	m.fee = &f
	m.addfee = nil
}

// Fee returns the value of the "fee" field in the mutation.
func (m *MedicalSurgeryMutation) Fee() (r float64, exists bool) {
	v := m.fee
	if v == nil {
		return
	}
	return *v, true
}

// OldFee returns the old "fee" field's value of the MedicalSurgery entity.
// If the MedicalSurgery object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MedicalSurgeryMutation) OldFee(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFee is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFee requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFee: %w", err)
	}
	return oldValue.Fee, nil
}

// AddFee adds f to the "fee" field.
func (m *MedicalSurgeryMutation) AddFee(f float64) {
	if m.addfee != nil {
		*m.addfee += f
	} else {
		m.addfee = &f
	}
}

// AddedFee returns the value that was added to the "fee" field in this mutation.
func (m *MedicalSurgeryMutation) AddedFee() (r float64, exists bool) {
	v := m.addfee
	if v == nil {
		return
	}
	return *v, true
}

// ResetFee resets all changes to the "fee" field.
func (m *MedicalSurgeryMutation) ResetFee() {
	m.fee = nil
	m.addfee = nil
}

// SetMainDoctorID sets the "main_doctor_id" field.
func (m *MedicalSurgeryMutation) SetMainDoctorID(u uuid.UUID) {
	m.main_doctor_id = &u
}

// MainDoctorID returns the value of the "main_doctor_id" field in the mutation.
func (m *MedicalSurgeryMutation) MainDoctorID() (r uuid.UUID, exists bool) {
	v := m.main_doctor_id
	if v == nil {
		return
	}
	return *v, true
}

// OldMainDoctorID returns the old "main_doctor_id" field's value of the MedicalSurgery entity.
// If the MedicalSurgery object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MedicalSurgeryMutation) OldMainDoctorID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMainDoctorID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMainDoctorID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMainDoctorID: %w", err)
	}
	return oldValue.MainDoctorID, nil
}

// ResetMainDoctorID resets all changes to the "main_doctor_id" field.
func (m *MedicalSurgeryMutation) ResetMainDoctorID() {
	m.main_doctor_id = nil
}

// SetSupportDoctorIds sets the "support_doctor_ids" field.
func (m *MedicalSurgeryMutation) SetSupportDoctorIds(s string) {
	m.support_doctor_ids = &s
}

// SupportDoctorIds returns the value of the "support_doctor_ids" field in the mutation.
func (m *MedicalSurgeryMutation) SupportDoctorIds() (r string, exists bool) {
	v := m.support_doctor_ids
	if v == nil {
		return
	}
	return *v, true
}

// OldSupportDoctorIds returns the old "support_doctor_ids" field's value of the MedicalSurgery entity.
// If the MedicalSurgery object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MedicalSurgeryMutation) OldSupportDoctorIds(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSupportDoctorIds is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSupportDoctorIds requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSupportDoctorIds: %w", err)
	}
	return oldValue.SupportDoctorIds, nil
}

// ResetSupportDoctorIds resets all changes to the "support_doctor_ids" field.
func (m *MedicalSurgeryMutation) ResetSupportDoctorIds() {
	m.support_doctor_ids = nil
}

// SetSupportNurseIds sets the "support_nurse_ids" field.
func (m *MedicalSurgeryMutation) SetSupportNurseIds(s string) {
	m.support_nurse_ids = &s
}

// SupportNurseIds returns the value of the "support_nurse_ids" field in the mutation.
func (m *MedicalSurgeryMutation) SupportNurseIds() (r string, exists bool) {
	v := m.support_nurse_ids
	if v == nil {
		return
	}
	return *v, true
}

// OldSupportNurseIds returns the old "support_nurse_ids" field's value of the MedicalSurgery entity.
// If the MedicalSurgery object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MedicalSurgeryMutation) OldSupportNurseIds(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSupportNurseIds is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSupportNurseIds requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSupportNurseIds: %w", err)
	}
	return oldValue.SupportNurseIds, nil
}

// ResetSupportNurseIds resets all changes to the "support_nurse_ids" field.
func (m *MedicalSurgeryMutation) ResetSupportNurseIds() {
	m.support_nurse_ids = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *MedicalSurgeryMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *MedicalSurgeryMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the MedicalSurgery entity.
// If the MedicalSurgery object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MedicalSurgeryMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *MedicalSurgeryMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetCreatedBy sets the "created_by" field.
func (m *MedicalSurgeryMutation) SetCreatedBy(u uuid.UUID) {
	m.created_by = &u
}

// CreatedBy returns the value of the "created_by" field in the mutation.
func (m *MedicalSurgeryMutation) CreatedBy() (r uuid.UUID, exists bool) {
	v := m.created_by
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedBy returns the old "created_by" field's value of the MedicalSurgery entity.
// If the MedicalSurgery object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MedicalSurgeryMutation) OldCreatedBy(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedBy: %w", err)
	}
	return oldValue.CreatedBy, nil
}

// ResetCreatedBy resets all changes to the "created_by" field.
func (m *MedicalSurgeryMutation) ResetCreatedBy() {
	m.created_by = nil
}

// SetUpdatedBy sets the "updated_by" field.
func (m *MedicalSurgeryMutation) SetUpdatedBy(u uuid.UUID) {
	m.updated_by = &u
}

// UpdatedBy returns the value of the "updated_by" field in the mutation.
func (m *MedicalSurgeryMutation) UpdatedBy() (r uuid.UUID, exists bool) {
	v := m.updated_by
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedBy returns the old "updated_by" field's value of the MedicalSurgery entity.
// If the MedicalSurgery object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MedicalSurgeryMutation) OldUpdatedBy(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedBy: %w", err)
	}
	return oldValue.UpdatedBy, nil
}

// ResetUpdatedBy resets all changes to the "updated_by" field.
func (m *MedicalSurgeryMutation) ResetUpdatedBy() {
	m.updated_by = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *MedicalSurgeryMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *MedicalSurgeryMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the MedicalSurgery entity.
// If the MedicalSurgery object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MedicalSurgeryMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *MedicalSurgeryMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetMedicalHistoriesID sets the "medical_histories" edge to the MedicalHistories entity by id.
func (m *MedicalSurgeryMutation) SetMedicalHistoriesID(id uuid.UUID) {
	m.medical_histories = &id
}

// ClearMedicalHistories clears the "medical_histories" edge to the MedicalHistories entity.
func (m *MedicalSurgeryMutation) ClearMedicalHistories() {
	m.clearedmedical_histories = true
	m.clearedFields[medicalsurgery.FieldMedicalHistoryID] = struct{}{}
}

// MedicalHistoriesCleared reports if the "medical_histories" edge to the MedicalHistories entity was cleared.
func (m *MedicalSurgeryMutation) MedicalHistoriesCleared() bool {
	return m.clearedmedical_histories
}

// MedicalHistoriesID returns the "medical_histories" edge ID in the mutation.
func (m *MedicalSurgeryMutation) MedicalHistoriesID() (id uuid.UUID, exists bool) {
	if m.medical_histories != nil {
		return *m.medical_histories, true
	}
	return
}

// MedicalHistoriesIDs returns the "medical_histories" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// MedicalHistoriesID instead. It exists only for internal usage by the builders.
func (m *MedicalSurgeryMutation) MedicalHistoriesIDs() (ids []uuid.UUID) {
	if id := m.medical_histories; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetMedicalHistories resets all changes to the "medical_histories" edge.
func (m *MedicalSurgeryMutation) ResetMedicalHistories() {
	m.medical_histories = nil
	m.clearedmedical_histories = false
}

// Where appends a list predicates to the MedicalSurgeryMutation builder.
func (m *MedicalSurgeryMutation) Where(ps ...predicate.MedicalSurgery) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the MedicalSurgeryMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *MedicalSurgeryMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.MedicalSurgery, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *MedicalSurgeryMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *MedicalSurgeryMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (MedicalSurgery).
func (m *MedicalSurgeryMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *MedicalSurgeryMutation) Fields() []string {
	fields := make([]string, 0, 14)
	if m.medical_histories != nil {
		fields = append(fields, medicalsurgery.FieldMedicalHistoryID)
	}
	if m.start_date != nil {
		fields = append(fields, medicalsurgery.FieldStartDate)
	}
	if m.end_date != nil {
		fields = append(fields, medicalsurgery.FieldEndDate)
	}
	if m.name != nil {
		fields = append(fields, medicalsurgery.FieldName)
	}
	if m.result != nil {
		fields = append(fields, medicalsurgery.FieldResult)
	}
	if m.description != nil {
		fields = append(fields, medicalsurgery.FieldDescription)
	}
	if m.fee != nil {
		fields = append(fields, medicalsurgery.FieldFee)
	}
	if m.main_doctor_id != nil {
		fields = append(fields, medicalsurgery.FieldMainDoctorID)
	}
	if m.support_doctor_ids != nil {
		fields = append(fields, medicalsurgery.FieldSupportDoctorIds)
	}
	if m.support_nurse_ids != nil {
		fields = append(fields, medicalsurgery.FieldSupportNurseIds)
	}
	if m.created_at != nil {
		fields = append(fields, medicalsurgery.FieldCreatedAt)
	}
	if m.created_by != nil {
		fields = append(fields, medicalsurgery.FieldCreatedBy)
	}
	if m.updated_by != nil {
		fields = append(fields, medicalsurgery.FieldUpdatedBy)
	}
	if m.updated_at != nil {
		fields = append(fields, medicalsurgery.FieldUpdatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *MedicalSurgeryMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case medicalsurgery.FieldMedicalHistoryID:
		return m.MedicalHistoryID()
	case medicalsurgery.FieldStartDate:
		return m.StartDate()
	case medicalsurgery.FieldEndDate:
		return m.EndDate()
	case medicalsurgery.FieldName:
		return m.Name()
	case medicalsurgery.FieldResult:
		return m.Result()
	case medicalsurgery.FieldDescription:
		return m.Description()
	case medicalsurgery.FieldFee:
		return m.Fee()
	case medicalsurgery.FieldMainDoctorID:
		return m.MainDoctorID()
	case medicalsurgery.FieldSupportDoctorIds:
		return m.SupportDoctorIds()
	case medicalsurgery.FieldSupportNurseIds:
		return m.SupportNurseIds()
	case medicalsurgery.FieldCreatedAt:
		return m.CreatedAt()
	case medicalsurgery.FieldCreatedBy:
		return m.CreatedBy()
	case medicalsurgery.FieldUpdatedBy:
		return m.UpdatedBy()
	case medicalsurgery.FieldUpdatedAt:
		return m.UpdatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *MedicalSurgeryMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case medicalsurgery.FieldMedicalHistoryID:
		return m.OldMedicalHistoryID(ctx)
	case medicalsurgery.FieldStartDate:
		return m.OldStartDate(ctx)
	case medicalsurgery.FieldEndDate:
		return m.OldEndDate(ctx)
	case medicalsurgery.FieldName:
		return m.OldName(ctx)
	case medicalsurgery.FieldResult:
		return m.OldResult(ctx)
	case medicalsurgery.FieldDescription:
		return m.OldDescription(ctx)
	case medicalsurgery.FieldFee:
		return m.OldFee(ctx)
	case medicalsurgery.FieldMainDoctorID:
		return m.OldMainDoctorID(ctx)
	case medicalsurgery.FieldSupportDoctorIds:
		return m.OldSupportDoctorIds(ctx)
	case medicalsurgery.FieldSupportNurseIds:
		return m.OldSupportNurseIds(ctx)
	case medicalsurgery.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case medicalsurgery.FieldCreatedBy:
		return m.OldCreatedBy(ctx)
	case medicalsurgery.FieldUpdatedBy:
		return m.OldUpdatedBy(ctx)
	case medicalsurgery.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown MedicalSurgery field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *MedicalSurgeryMutation) SetField(name string, value ent.Value) error {
	switch name {
	case medicalsurgery.FieldMedicalHistoryID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMedicalHistoryID(v)
		return nil
	case medicalsurgery.FieldStartDate:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStartDate(v)
		return nil
	case medicalsurgery.FieldEndDate:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEndDate(v)
		return nil
	case medicalsurgery.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case medicalsurgery.FieldResult:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetResult(v)
		return nil
	case medicalsurgery.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	case medicalsurgery.FieldFee:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFee(v)
		return nil
	case medicalsurgery.FieldMainDoctorID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMainDoctorID(v)
		return nil
	case medicalsurgery.FieldSupportDoctorIds:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSupportDoctorIds(v)
		return nil
	case medicalsurgery.FieldSupportNurseIds:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSupportNurseIds(v)
		return nil
	case medicalsurgery.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case medicalsurgery.FieldCreatedBy:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedBy(v)
		return nil
	case medicalsurgery.FieldUpdatedBy:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedBy(v)
		return nil
	case medicalsurgery.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown MedicalSurgery field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *MedicalSurgeryMutation) AddedFields() []string {
	var fields []string
	if m.addfee != nil {
		fields = append(fields, medicalsurgery.FieldFee)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *MedicalSurgeryMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case medicalsurgery.FieldFee:
		return m.AddedFee()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *MedicalSurgeryMutation) AddField(name string, value ent.Value) error {
	switch name {
	case medicalsurgery.FieldFee:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddFee(v)
		return nil
	}
	return fmt.Errorf("unknown MedicalSurgery numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *MedicalSurgeryMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *MedicalSurgeryMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *MedicalSurgeryMutation) ClearField(name string) error {
	return fmt.Errorf("unknown MedicalSurgery nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *MedicalSurgeryMutation) ResetField(name string) error {
	switch name {
	case medicalsurgery.FieldMedicalHistoryID:
		m.ResetMedicalHistoryID()
		return nil
	case medicalsurgery.FieldStartDate:
		m.ResetStartDate()
		return nil
	case medicalsurgery.FieldEndDate:
		m.ResetEndDate()
		return nil
	case medicalsurgery.FieldName:
		m.ResetName()
		return nil
	case medicalsurgery.FieldResult:
		m.ResetResult()
		return nil
	case medicalsurgery.FieldDescription:
		m.ResetDescription()
		return nil
	case medicalsurgery.FieldFee:
		m.ResetFee()
		return nil
	case medicalsurgery.FieldMainDoctorID:
		m.ResetMainDoctorID()
		return nil
	case medicalsurgery.FieldSupportDoctorIds:
		m.ResetSupportDoctorIds()
		return nil
	case medicalsurgery.FieldSupportNurseIds:
		m.ResetSupportNurseIds()
		return nil
	case medicalsurgery.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case medicalsurgery.FieldCreatedBy:
		m.ResetCreatedBy()
		return nil
	case medicalsurgery.FieldUpdatedBy:
		m.ResetUpdatedBy()
		return nil
	case medicalsurgery.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	}
	return fmt.Errorf("unknown MedicalSurgery field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *MedicalSurgeryMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.medical_histories != nil {
		edges = append(edges, medicalsurgery.EdgeMedicalHistories)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *MedicalSurgeryMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case medicalsurgery.EdgeMedicalHistories:
		if id := m.medical_histories; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *MedicalSurgeryMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *MedicalSurgeryMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *MedicalSurgeryMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedmedical_histories {
		edges = append(edges, medicalsurgery.EdgeMedicalHistories)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *MedicalSurgeryMutation) EdgeCleared(name string) bool {
	switch name {
	case medicalsurgery.EdgeMedicalHistories:
		return m.clearedmedical_histories
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *MedicalSurgeryMutation) ClearEdge(name string) error {
	switch name {
	case medicalsurgery.EdgeMedicalHistories:
		m.ClearMedicalHistories()
		return nil
	}
	return fmt.Errorf("unknown MedicalSurgery unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *MedicalSurgeryMutation) ResetEdge(name string) error {
	switch name {
	case medicalsurgery.EdgeMedicalHistories:
		m.ResetMedicalHistories()
		return nil
	}
	return fmt.Errorf("unknown MedicalSurgery edge %s", name)
}

// MedicalTreatmentMutation represents an operation that mutates the MedicalTreatment nodes in the graph.
type MedicalTreatmentMutation struct {
	config
	op                       Op
	typ                      string
	id                       *uuid.UUID
	start_date               *time.Time
	end_date                 *time.Time
	name                     *string
	result                   *string
	description              *string
	fee                      *float64
	addfee                   *float64
	main_doctor_id           *uuid.UUID
	support_doctor_ids       *string
	support_nurse_ids        *string
	created_at               *time.Time
	created_by               *uuid.UUID
	updated_by               *uuid.UUID
	updated_at               *time.Time
	clearedFields            map[string]struct{}
	medical_histories        *uuid.UUID
	clearedmedical_histories bool
	done                     bool
	oldValue                 func(context.Context) (*MedicalTreatment, error)
	predicates               []predicate.MedicalTreatment
}

var _ ent.Mutation = (*MedicalTreatmentMutation)(nil)

// medicaltreatmentOption allows management of the mutation configuration using functional options.
type medicaltreatmentOption func(*MedicalTreatmentMutation)

// newMedicalTreatmentMutation creates new mutation for the MedicalTreatment entity.
func newMedicalTreatmentMutation(c config, op Op, opts ...medicaltreatmentOption) *MedicalTreatmentMutation {
	m := &MedicalTreatmentMutation{
		config:        c,
		op:            op,
		typ:           TypeMedicalTreatment,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withMedicalTreatmentID sets the ID field of the mutation.
func withMedicalTreatmentID(id uuid.UUID) medicaltreatmentOption {
	return func(m *MedicalTreatmentMutation) {
		var (
			err   error
			once  sync.Once
			value *MedicalTreatment
		)
		m.oldValue = func(ctx context.Context) (*MedicalTreatment, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().MedicalTreatment.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withMedicalTreatment sets the old MedicalTreatment of the mutation.
func withMedicalTreatment(node *MedicalTreatment) medicaltreatmentOption {
	return func(m *MedicalTreatmentMutation) {
		m.oldValue = func(context.Context) (*MedicalTreatment, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m MedicalTreatmentMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m MedicalTreatmentMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of MedicalTreatment entities.
func (m *MedicalTreatmentMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *MedicalTreatmentMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *MedicalTreatmentMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().MedicalTreatment.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetMedicalHistoryID sets the "medical_history_id" field.
func (m *MedicalTreatmentMutation) SetMedicalHistoryID(u uuid.UUID) {
	m.medical_histories = &u
}

// MedicalHistoryID returns the value of the "medical_history_id" field in the mutation.
func (m *MedicalTreatmentMutation) MedicalHistoryID() (r uuid.UUID, exists bool) {
	v := m.medical_histories
	if v == nil {
		return
	}
	return *v, true
}

// OldMedicalHistoryID returns the old "medical_history_id" field's value of the MedicalTreatment entity.
// If the MedicalTreatment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MedicalTreatmentMutation) OldMedicalHistoryID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMedicalHistoryID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMedicalHistoryID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMedicalHistoryID: %w", err)
	}
	return oldValue.MedicalHistoryID, nil
}

// ResetMedicalHistoryID resets all changes to the "medical_history_id" field.
func (m *MedicalTreatmentMutation) ResetMedicalHistoryID() {
	m.medical_histories = nil
}

// SetStartDate sets the "start_date" field.
func (m *MedicalTreatmentMutation) SetStartDate(t time.Time) {
	m.start_date = &t
}

// StartDate returns the value of the "start_date" field in the mutation.
func (m *MedicalTreatmentMutation) StartDate() (r time.Time, exists bool) {
	v := m.start_date
	if v == nil {
		return
	}
	return *v, true
}

// OldStartDate returns the old "start_date" field's value of the MedicalTreatment entity.
// If the MedicalTreatment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MedicalTreatmentMutation) OldStartDate(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStartDate is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStartDate requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStartDate: %w", err)
	}
	return oldValue.StartDate, nil
}

// ResetStartDate resets all changes to the "start_date" field.
func (m *MedicalTreatmentMutation) ResetStartDate() {
	m.start_date = nil
}

// SetEndDate sets the "end_date" field.
func (m *MedicalTreatmentMutation) SetEndDate(t time.Time) {
	m.end_date = &t
}

// EndDate returns the value of the "end_date" field in the mutation.
func (m *MedicalTreatmentMutation) EndDate() (r time.Time, exists bool) {
	v := m.end_date
	if v == nil {
		return
	}
	return *v, true
}

// OldEndDate returns the old "end_date" field's value of the MedicalTreatment entity.
// If the MedicalTreatment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MedicalTreatmentMutation) OldEndDate(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEndDate is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEndDate requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEndDate: %w", err)
	}
	return oldValue.EndDate, nil
}

// ResetEndDate resets all changes to the "end_date" field.
func (m *MedicalTreatmentMutation) ResetEndDate() {
	m.end_date = nil
}

// SetName sets the "name" field.
func (m *MedicalTreatmentMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *MedicalTreatmentMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the MedicalTreatment entity.
// If the MedicalTreatment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MedicalTreatmentMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *MedicalTreatmentMutation) ResetName() {
	m.name = nil
}

// SetResult sets the "result" field.
func (m *MedicalTreatmentMutation) SetResult(s string) {
	m.result = &s
}

// Result returns the value of the "result" field in the mutation.
func (m *MedicalTreatmentMutation) Result() (r string, exists bool) {
	v := m.result
	if v == nil {
		return
	}
	return *v, true
}

// OldResult returns the old "result" field's value of the MedicalTreatment entity.
// If the MedicalTreatment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MedicalTreatmentMutation) OldResult(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldResult is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldResult requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldResult: %w", err)
	}
	return oldValue.Result, nil
}

// ResetResult resets all changes to the "result" field.
func (m *MedicalTreatmentMutation) ResetResult() {
	m.result = nil
}

// SetDescription sets the "description" field.
func (m *MedicalTreatmentMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *MedicalTreatmentMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the MedicalTreatment entity.
// If the MedicalTreatment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MedicalTreatmentMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ResetDescription resets all changes to the "description" field.
func (m *MedicalTreatmentMutation) ResetDescription() {
	m.description = nil
}

// SetFee sets the "fee" field.
func (m *MedicalTreatmentMutation) SetFee(f float64) {
	m.fee = &f
	m.addfee = nil
}

// Fee returns the value of the "fee" field in the mutation.
func (m *MedicalTreatmentMutation) Fee() (r float64, exists bool) {
	v := m.fee
	if v == nil {
		return
	}
	return *v, true
}

// OldFee returns the old "fee" field's value of the MedicalTreatment entity.
// If the MedicalTreatment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MedicalTreatmentMutation) OldFee(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFee is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFee requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFee: %w", err)
	}
	return oldValue.Fee, nil
}

// AddFee adds f to the "fee" field.
func (m *MedicalTreatmentMutation) AddFee(f float64) {
	if m.addfee != nil {
		*m.addfee += f
	} else {
		m.addfee = &f
	}
}

// AddedFee returns the value that was added to the "fee" field in this mutation.
func (m *MedicalTreatmentMutation) AddedFee() (r float64, exists bool) {
	v := m.addfee
	if v == nil {
		return
	}
	return *v, true
}

// ResetFee resets all changes to the "fee" field.
func (m *MedicalTreatmentMutation) ResetFee() {
	m.fee = nil
	m.addfee = nil
}

// SetMainDoctorID sets the "main_doctor_id" field.
func (m *MedicalTreatmentMutation) SetMainDoctorID(u uuid.UUID) {
	m.main_doctor_id = &u
}

// MainDoctorID returns the value of the "main_doctor_id" field in the mutation.
func (m *MedicalTreatmentMutation) MainDoctorID() (r uuid.UUID, exists bool) {
	v := m.main_doctor_id
	if v == nil {
		return
	}
	return *v, true
}

// OldMainDoctorID returns the old "main_doctor_id" field's value of the MedicalTreatment entity.
// If the MedicalTreatment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MedicalTreatmentMutation) OldMainDoctorID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMainDoctorID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMainDoctorID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMainDoctorID: %w", err)
	}
	return oldValue.MainDoctorID, nil
}

// ResetMainDoctorID resets all changes to the "main_doctor_id" field.
func (m *MedicalTreatmentMutation) ResetMainDoctorID() {
	m.main_doctor_id = nil
}

// SetSupportDoctorIds sets the "support_doctor_ids" field.
func (m *MedicalTreatmentMutation) SetSupportDoctorIds(s string) {
	m.support_doctor_ids = &s
}

// SupportDoctorIds returns the value of the "support_doctor_ids" field in the mutation.
func (m *MedicalTreatmentMutation) SupportDoctorIds() (r string, exists bool) {
	v := m.support_doctor_ids
	if v == nil {
		return
	}
	return *v, true
}

// OldSupportDoctorIds returns the old "support_doctor_ids" field's value of the MedicalTreatment entity.
// If the MedicalTreatment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MedicalTreatmentMutation) OldSupportDoctorIds(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSupportDoctorIds is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSupportDoctorIds requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSupportDoctorIds: %w", err)
	}
	return oldValue.SupportDoctorIds, nil
}

// ResetSupportDoctorIds resets all changes to the "support_doctor_ids" field.
func (m *MedicalTreatmentMutation) ResetSupportDoctorIds() {
	m.support_doctor_ids = nil
}

// SetSupportNurseIds sets the "support_nurse_ids" field.
func (m *MedicalTreatmentMutation) SetSupportNurseIds(s string) {
	m.support_nurse_ids = &s
}

// SupportNurseIds returns the value of the "support_nurse_ids" field in the mutation.
func (m *MedicalTreatmentMutation) SupportNurseIds() (r string, exists bool) {
	v := m.support_nurse_ids
	if v == nil {
		return
	}
	return *v, true
}

// OldSupportNurseIds returns the old "support_nurse_ids" field's value of the MedicalTreatment entity.
// If the MedicalTreatment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MedicalTreatmentMutation) OldSupportNurseIds(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSupportNurseIds is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSupportNurseIds requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSupportNurseIds: %w", err)
	}
	return oldValue.SupportNurseIds, nil
}

// ResetSupportNurseIds resets all changes to the "support_nurse_ids" field.
func (m *MedicalTreatmentMutation) ResetSupportNurseIds() {
	m.support_nurse_ids = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *MedicalTreatmentMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *MedicalTreatmentMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the MedicalTreatment entity.
// If the MedicalTreatment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MedicalTreatmentMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *MedicalTreatmentMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetCreatedBy sets the "created_by" field.
func (m *MedicalTreatmentMutation) SetCreatedBy(u uuid.UUID) {
	m.created_by = &u
}

// CreatedBy returns the value of the "created_by" field in the mutation.
func (m *MedicalTreatmentMutation) CreatedBy() (r uuid.UUID, exists bool) {
	v := m.created_by
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedBy returns the old "created_by" field's value of the MedicalTreatment entity.
// If the MedicalTreatment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MedicalTreatmentMutation) OldCreatedBy(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedBy: %w", err)
	}
	return oldValue.CreatedBy, nil
}

// ResetCreatedBy resets all changes to the "created_by" field.
func (m *MedicalTreatmentMutation) ResetCreatedBy() {
	m.created_by = nil
}

// SetUpdatedBy sets the "updated_by" field.
func (m *MedicalTreatmentMutation) SetUpdatedBy(u uuid.UUID) {
	m.updated_by = &u
}

// UpdatedBy returns the value of the "updated_by" field in the mutation.
func (m *MedicalTreatmentMutation) UpdatedBy() (r uuid.UUID, exists bool) {
	v := m.updated_by
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedBy returns the old "updated_by" field's value of the MedicalTreatment entity.
// If the MedicalTreatment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MedicalTreatmentMutation) OldUpdatedBy(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedBy: %w", err)
	}
	return oldValue.UpdatedBy, nil
}

// ResetUpdatedBy resets all changes to the "updated_by" field.
func (m *MedicalTreatmentMutation) ResetUpdatedBy() {
	m.updated_by = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *MedicalTreatmentMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *MedicalTreatmentMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the MedicalTreatment entity.
// If the MedicalTreatment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MedicalTreatmentMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *MedicalTreatmentMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetMedicalHistoriesID sets the "medical_histories" edge to the MedicalHistories entity by id.
func (m *MedicalTreatmentMutation) SetMedicalHistoriesID(id uuid.UUID) {
	m.medical_histories = &id
}

// ClearMedicalHistories clears the "medical_histories" edge to the MedicalHistories entity.
func (m *MedicalTreatmentMutation) ClearMedicalHistories() {
	m.clearedmedical_histories = true
	m.clearedFields[medicaltreatment.FieldMedicalHistoryID] = struct{}{}
}

// MedicalHistoriesCleared reports if the "medical_histories" edge to the MedicalHistories entity was cleared.
func (m *MedicalTreatmentMutation) MedicalHistoriesCleared() bool {
	return m.clearedmedical_histories
}

// MedicalHistoriesID returns the "medical_histories" edge ID in the mutation.
func (m *MedicalTreatmentMutation) MedicalHistoriesID() (id uuid.UUID, exists bool) {
	if m.medical_histories != nil {
		return *m.medical_histories, true
	}
	return
}

// MedicalHistoriesIDs returns the "medical_histories" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// MedicalHistoriesID instead. It exists only for internal usage by the builders.
func (m *MedicalTreatmentMutation) MedicalHistoriesIDs() (ids []uuid.UUID) {
	if id := m.medical_histories; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetMedicalHistories resets all changes to the "medical_histories" edge.
func (m *MedicalTreatmentMutation) ResetMedicalHistories() {
	m.medical_histories = nil
	m.clearedmedical_histories = false
}

// Where appends a list predicates to the MedicalTreatmentMutation builder.
func (m *MedicalTreatmentMutation) Where(ps ...predicate.MedicalTreatment) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the MedicalTreatmentMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *MedicalTreatmentMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.MedicalTreatment, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *MedicalTreatmentMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *MedicalTreatmentMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (MedicalTreatment).
func (m *MedicalTreatmentMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *MedicalTreatmentMutation) Fields() []string {
	fields := make([]string, 0, 14)
	if m.medical_histories != nil {
		fields = append(fields, medicaltreatment.FieldMedicalHistoryID)
	}
	if m.start_date != nil {
		fields = append(fields, medicaltreatment.FieldStartDate)
	}
	if m.end_date != nil {
		fields = append(fields, medicaltreatment.FieldEndDate)
	}
	if m.name != nil {
		fields = append(fields, medicaltreatment.FieldName)
	}
	if m.result != nil {
		fields = append(fields, medicaltreatment.FieldResult)
	}
	if m.description != nil {
		fields = append(fields, medicaltreatment.FieldDescription)
	}
	if m.fee != nil {
		fields = append(fields, medicaltreatment.FieldFee)
	}
	if m.main_doctor_id != nil {
		fields = append(fields, medicaltreatment.FieldMainDoctorID)
	}
	if m.support_doctor_ids != nil {
		fields = append(fields, medicaltreatment.FieldSupportDoctorIds)
	}
	if m.support_nurse_ids != nil {
		fields = append(fields, medicaltreatment.FieldSupportNurseIds)
	}
	if m.created_at != nil {
		fields = append(fields, medicaltreatment.FieldCreatedAt)
	}
	if m.created_by != nil {
		fields = append(fields, medicaltreatment.FieldCreatedBy)
	}
	if m.updated_by != nil {
		fields = append(fields, medicaltreatment.FieldUpdatedBy)
	}
	if m.updated_at != nil {
		fields = append(fields, medicaltreatment.FieldUpdatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *MedicalTreatmentMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case medicaltreatment.FieldMedicalHistoryID:
		return m.MedicalHistoryID()
	case medicaltreatment.FieldStartDate:
		return m.StartDate()
	case medicaltreatment.FieldEndDate:
		return m.EndDate()
	case medicaltreatment.FieldName:
		return m.Name()
	case medicaltreatment.FieldResult:
		return m.Result()
	case medicaltreatment.FieldDescription:
		return m.Description()
	case medicaltreatment.FieldFee:
		return m.Fee()
	case medicaltreatment.FieldMainDoctorID:
		return m.MainDoctorID()
	case medicaltreatment.FieldSupportDoctorIds:
		return m.SupportDoctorIds()
	case medicaltreatment.FieldSupportNurseIds:
		return m.SupportNurseIds()
	case medicaltreatment.FieldCreatedAt:
		return m.CreatedAt()
	case medicaltreatment.FieldCreatedBy:
		return m.CreatedBy()
	case medicaltreatment.FieldUpdatedBy:
		return m.UpdatedBy()
	case medicaltreatment.FieldUpdatedAt:
		return m.UpdatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *MedicalTreatmentMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case medicaltreatment.FieldMedicalHistoryID:
		return m.OldMedicalHistoryID(ctx)
	case medicaltreatment.FieldStartDate:
		return m.OldStartDate(ctx)
	case medicaltreatment.FieldEndDate:
		return m.OldEndDate(ctx)
	case medicaltreatment.FieldName:
		return m.OldName(ctx)
	case medicaltreatment.FieldResult:
		return m.OldResult(ctx)
	case medicaltreatment.FieldDescription:
		return m.OldDescription(ctx)
	case medicaltreatment.FieldFee:
		return m.OldFee(ctx)
	case medicaltreatment.FieldMainDoctorID:
		return m.OldMainDoctorID(ctx)
	case medicaltreatment.FieldSupportDoctorIds:
		return m.OldSupportDoctorIds(ctx)
	case medicaltreatment.FieldSupportNurseIds:
		return m.OldSupportNurseIds(ctx)
	case medicaltreatment.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case medicaltreatment.FieldCreatedBy:
		return m.OldCreatedBy(ctx)
	case medicaltreatment.FieldUpdatedBy:
		return m.OldUpdatedBy(ctx)
	case medicaltreatment.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown MedicalTreatment field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *MedicalTreatmentMutation) SetField(name string, value ent.Value) error {
	switch name {
	case medicaltreatment.FieldMedicalHistoryID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMedicalHistoryID(v)
		return nil
	case medicaltreatment.FieldStartDate:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStartDate(v)
		return nil
	case medicaltreatment.FieldEndDate:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEndDate(v)
		return nil
	case medicaltreatment.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case medicaltreatment.FieldResult:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetResult(v)
		return nil
	case medicaltreatment.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	case medicaltreatment.FieldFee:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFee(v)
		return nil
	case medicaltreatment.FieldMainDoctorID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMainDoctorID(v)
		return nil
	case medicaltreatment.FieldSupportDoctorIds:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSupportDoctorIds(v)
		return nil
	case medicaltreatment.FieldSupportNurseIds:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSupportNurseIds(v)
		return nil
	case medicaltreatment.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case medicaltreatment.FieldCreatedBy:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedBy(v)
		return nil
	case medicaltreatment.FieldUpdatedBy:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedBy(v)
		return nil
	case medicaltreatment.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown MedicalTreatment field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *MedicalTreatmentMutation) AddedFields() []string {
	var fields []string
	if m.addfee != nil {
		fields = append(fields, medicaltreatment.FieldFee)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *MedicalTreatmentMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case medicaltreatment.FieldFee:
		return m.AddedFee()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *MedicalTreatmentMutation) AddField(name string, value ent.Value) error {
	switch name {
	case medicaltreatment.FieldFee:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddFee(v)
		return nil
	}
	return fmt.Errorf("unknown MedicalTreatment numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *MedicalTreatmentMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *MedicalTreatmentMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *MedicalTreatmentMutation) ClearField(name string) error {
	return fmt.Errorf("unknown MedicalTreatment nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *MedicalTreatmentMutation) ResetField(name string) error {
	switch name {
	case medicaltreatment.FieldMedicalHistoryID:
		m.ResetMedicalHistoryID()
		return nil
	case medicaltreatment.FieldStartDate:
		m.ResetStartDate()
		return nil
	case medicaltreatment.FieldEndDate:
		m.ResetEndDate()
		return nil
	case medicaltreatment.FieldName:
		m.ResetName()
		return nil
	case medicaltreatment.FieldResult:
		m.ResetResult()
		return nil
	case medicaltreatment.FieldDescription:
		m.ResetDescription()
		return nil
	case medicaltreatment.FieldFee:
		m.ResetFee()
		return nil
	case medicaltreatment.FieldMainDoctorID:
		m.ResetMainDoctorID()
		return nil
	case medicaltreatment.FieldSupportDoctorIds:
		m.ResetSupportDoctorIds()
		return nil
	case medicaltreatment.FieldSupportNurseIds:
		m.ResetSupportNurseIds()
		return nil
	case medicaltreatment.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case medicaltreatment.FieldCreatedBy:
		m.ResetCreatedBy()
		return nil
	case medicaltreatment.FieldUpdatedBy:
		m.ResetUpdatedBy()
		return nil
	case medicaltreatment.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	}
	return fmt.Errorf("unknown MedicalTreatment field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *MedicalTreatmentMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.medical_histories != nil {
		edges = append(edges, medicaltreatment.EdgeMedicalHistories)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *MedicalTreatmentMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case medicaltreatment.EdgeMedicalHistories:
		if id := m.medical_histories; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *MedicalTreatmentMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *MedicalTreatmentMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *MedicalTreatmentMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedmedical_histories {
		edges = append(edges, medicaltreatment.EdgeMedicalHistories)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *MedicalTreatmentMutation) EdgeCleared(name string) bool {
	switch name {
	case medicaltreatment.EdgeMedicalHistories:
		return m.clearedmedical_histories
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *MedicalTreatmentMutation) ClearEdge(name string) error {
	switch name {
	case medicaltreatment.EdgeMedicalHistories:
		m.ClearMedicalHistories()
		return nil
	}
	return fmt.Errorf("unknown MedicalTreatment unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *MedicalTreatmentMutation) ResetEdge(name string) error {
	switch name {
	case medicaltreatment.EdgeMedicalHistories:
		m.ResetMedicalHistories()
		return nil
	}
	return fmt.Errorf("unknown MedicalTreatment edge %s", name)
}

// MedicationMutation represents an operation that mutates the Medication nodes in the graph.
type MedicationMutation struct {
	config
	op                             Op
	typ                            string
	id                             *uuid.UUID
	name                           *string
	effects                        *string
	expired_date                   *time.Time
	quantity                       *int64
	addquantity                    *int64
	price                          *float64
	addprice                       *float64
	created_by                     *uuid.UUID
	updated_by                     *uuid.UUID
	created_at                     *time.Time
	updated_at                     *time.Time
	clearedFields                  map[string]struct{}
	prescription_medication        map[uuid.UUID]struct{}
	removedprescription_medication map[uuid.UUID]struct{}
	clearedprescription_medication bool
	done                           bool
	oldValue                       func(context.Context) (*Medication, error)
	predicates                     []predicate.Medication
}

var _ ent.Mutation = (*MedicationMutation)(nil)

// medicationOption allows management of the mutation configuration using functional options.
type medicationOption func(*MedicationMutation)

// newMedicationMutation creates new mutation for the Medication entity.
func newMedicationMutation(c config, op Op, opts ...medicationOption) *MedicationMutation {
	m := &MedicationMutation{
		config:        c,
		op:            op,
		typ:           TypeMedication,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withMedicationID sets the ID field of the mutation.
func withMedicationID(id uuid.UUID) medicationOption {
	return func(m *MedicationMutation) {
		var (
			err   error
			once  sync.Once
			value *Medication
		)
		m.oldValue = func(ctx context.Context) (*Medication, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Medication.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withMedication sets the old Medication of the mutation.
func withMedication(node *Medication) medicationOption {
	return func(m *MedicationMutation) {
		m.oldValue = func(context.Context) (*Medication, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m MedicationMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m MedicationMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Medication entities.
func (m *MedicationMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *MedicationMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *MedicationMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Medication.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetName sets the "name" field.
func (m *MedicationMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *MedicationMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Medication entity.
// If the Medication object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MedicationMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *MedicationMutation) ResetName() {
	m.name = nil
}

// SetEffects sets the "effects" field.
func (m *MedicationMutation) SetEffects(s string) {
	m.effects = &s
}

// Effects returns the value of the "effects" field in the mutation.
func (m *MedicationMutation) Effects() (r string, exists bool) {
	v := m.effects
	if v == nil {
		return
	}
	return *v, true
}

// OldEffects returns the old "effects" field's value of the Medication entity.
// If the Medication object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MedicationMutation) OldEffects(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEffects is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEffects requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEffects: %w", err)
	}
	return oldValue.Effects, nil
}

// ResetEffects resets all changes to the "effects" field.
func (m *MedicationMutation) ResetEffects() {
	m.effects = nil
}

// SetExpiredDate sets the "expired_date" field.
func (m *MedicationMutation) SetExpiredDate(t time.Time) {
	m.expired_date = &t
}

// ExpiredDate returns the value of the "expired_date" field in the mutation.
func (m *MedicationMutation) ExpiredDate() (r time.Time, exists bool) {
	v := m.expired_date
	if v == nil {
		return
	}
	return *v, true
}

// OldExpiredDate returns the old "expired_date" field's value of the Medication entity.
// If the Medication object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MedicationMutation) OldExpiredDate(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldExpiredDate is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldExpiredDate requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldExpiredDate: %w", err)
	}
	return oldValue.ExpiredDate, nil
}

// ResetExpiredDate resets all changes to the "expired_date" field.
func (m *MedicationMutation) ResetExpiredDate() {
	m.expired_date = nil
}

// SetQuantity sets the "quantity" field.
func (m *MedicationMutation) SetQuantity(i int64) {
	m.quantity = &i
	m.addquantity = nil
}

// Quantity returns the value of the "quantity" field in the mutation.
func (m *MedicationMutation) Quantity() (r int64, exists bool) {
	v := m.quantity
	if v == nil {
		return
	}
	return *v, true
}

// OldQuantity returns the old "quantity" field's value of the Medication entity.
// If the Medication object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MedicationMutation) OldQuantity(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldQuantity is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldQuantity requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldQuantity: %w", err)
	}
	return oldValue.Quantity, nil
}

// AddQuantity adds i to the "quantity" field.
func (m *MedicationMutation) AddQuantity(i int64) {
	if m.addquantity != nil {
		*m.addquantity += i
	} else {
		m.addquantity = &i
	}
}

// AddedQuantity returns the value that was added to the "quantity" field in this mutation.
func (m *MedicationMutation) AddedQuantity() (r int64, exists bool) {
	v := m.addquantity
	if v == nil {
		return
	}
	return *v, true
}

// ResetQuantity resets all changes to the "quantity" field.
func (m *MedicationMutation) ResetQuantity() {
	m.quantity = nil
	m.addquantity = nil
}

// SetPrice sets the "price" field.
func (m *MedicationMutation) SetPrice(f float64) {
	m.price = &f
	m.addprice = nil
}

// Price returns the value of the "price" field in the mutation.
func (m *MedicationMutation) Price() (r float64, exists bool) {
	v := m.price
	if v == nil {
		return
	}
	return *v, true
}

// OldPrice returns the old "price" field's value of the Medication entity.
// If the Medication object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MedicationMutation) OldPrice(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPrice is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPrice requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPrice: %w", err)
	}
	return oldValue.Price, nil
}

// AddPrice adds f to the "price" field.
func (m *MedicationMutation) AddPrice(f float64) {
	if m.addprice != nil {
		*m.addprice += f
	} else {
		m.addprice = &f
	}
}

// AddedPrice returns the value that was added to the "price" field in this mutation.
func (m *MedicationMutation) AddedPrice() (r float64, exists bool) {
	v := m.addprice
	if v == nil {
		return
	}
	return *v, true
}

// ResetPrice resets all changes to the "price" field.
func (m *MedicationMutation) ResetPrice() {
	m.price = nil
	m.addprice = nil
}

// SetCreatedBy sets the "created_by" field.
func (m *MedicationMutation) SetCreatedBy(u uuid.UUID) {
	m.created_by = &u
}

// CreatedBy returns the value of the "created_by" field in the mutation.
func (m *MedicationMutation) CreatedBy() (r uuid.UUID, exists bool) {
	v := m.created_by
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedBy returns the old "created_by" field's value of the Medication entity.
// If the Medication object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MedicationMutation) OldCreatedBy(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedBy: %w", err)
	}
	return oldValue.CreatedBy, nil
}

// ResetCreatedBy resets all changes to the "created_by" field.
func (m *MedicationMutation) ResetCreatedBy() {
	m.created_by = nil
}

// SetUpdatedBy sets the "updated_by" field.
func (m *MedicationMutation) SetUpdatedBy(u uuid.UUID) {
	m.updated_by = &u
}

// UpdatedBy returns the value of the "updated_by" field in the mutation.
func (m *MedicationMutation) UpdatedBy() (r uuid.UUID, exists bool) {
	v := m.updated_by
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedBy returns the old "updated_by" field's value of the Medication entity.
// If the Medication object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MedicationMutation) OldUpdatedBy(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedBy: %w", err)
	}
	return oldValue.UpdatedBy, nil
}

// ResetUpdatedBy resets all changes to the "updated_by" field.
func (m *MedicationMutation) ResetUpdatedBy() {
	m.updated_by = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *MedicationMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *MedicationMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Medication entity.
// If the Medication object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MedicationMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *MedicationMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *MedicationMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *MedicationMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Medication entity.
// If the Medication object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MedicationMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *MedicationMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// AddPrescriptionMedicationIDs adds the "prescription_medication" edge to the PrescriptionMedication entity by ids.
func (m *MedicationMutation) AddPrescriptionMedicationIDs(ids ...uuid.UUID) {
	if m.prescription_medication == nil {
		m.prescription_medication = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.prescription_medication[ids[i]] = struct{}{}
	}
}

// ClearPrescriptionMedication clears the "prescription_medication" edge to the PrescriptionMedication entity.
func (m *MedicationMutation) ClearPrescriptionMedication() {
	m.clearedprescription_medication = true
}

// PrescriptionMedicationCleared reports if the "prescription_medication" edge to the PrescriptionMedication entity was cleared.
func (m *MedicationMutation) PrescriptionMedicationCleared() bool {
	return m.clearedprescription_medication
}

// RemovePrescriptionMedicationIDs removes the "prescription_medication" edge to the PrescriptionMedication entity by IDs.
func (m *MedicationMutation) RemovePrescriptionMedicationIDs(ids ...uuid.UUID) {
	if m.removedprescription_medication == nil {
		m.removedprescription_medication = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.prescription_medication, ids[i])
		m.removedprescription_medication[ids[i]] = struct{}{}
	}
}

// RemovedPrescriptionMedication returns the removed IDs of the "prescription_medication" edge to the PrescriptionMedication entity.
func (m *MedicationMutation) RemovedPrescriptionMedicationIDs() (ids []uuid.UUID) {
	for id := range m.removedprescription_medication {
		ids = append(ids, id)
	}
	return
}

// PrescriptionMedicationIDs returns the "prescription_medication" edge IDs in the mutation.
func (m *MedicationMutation) PrescriptionMedicationIDs() (ids []uuid.UUID) {
	for id := range m.prescription_medication {
		ids = append(ids, id)
	}
	return
}

// ResetPrescriptionMedication resets all changes to the "prescription_medication" edge.
func (m *MedicationMutation) ResetPrescriptionMedication() {
	m.prescription_medication = nil
	m.clearedprescription_medication = false
	m.removedprescription_medication = nil
}

// Where appends a list predicates to the MedicationMutation builder.
func (m *MedicationMutation) Where(ps ...predicate.Medication) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the MedicationMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *MedicationMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Medication, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *MedicationMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *MedicationMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Medication).
func (m *MedicationMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *MedicationMutation) Fields() []string {
	fields := make([]string, 0, 9)
	if m.name != nil {
		fields = append(fields, medication.FieldName)
	}
	if m.effects != nil {
		fields = append(fields, medication.FieldEffects)
	}
	if m.expired_date != nil {
		fields = append(fields, medication.FieldExpiredDate)
	}
	if m.quantity != nil {
		fields = append(fields, medication.FieldQuantity)
	}
	if m.price != nil {
		fields = append(fields, medication.FieldPrice)
	}
	if m.created_by != nil {
		fields = append(fields, medication.FieldCreatedBy)
	}
	if m.updated_by != nil {
		fields = append(fields, medication.FieldUpdatedBy)
	}
	if m.created_at != nil {
		fields = append(fields, medication.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, medication.FieldUpdatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *MedicationMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case medication.FieldName:
		return m.Name()
	case medication.FieldEffects:
		return m.Effects()
	case medication.FieldExpiredDate:
		return m.ExpiredDate()
	case medication.FieldQuantity:
		return m.Quantity()
	case medication.FieldPrice:
		return m.Price()
	case medication.FieldCreatedBy:
		return m.CreatedBy()
	case medication.FieldUpdatedBy:
		return m.UpdatedBy()
	case medication.FieldCreatedAt:
		return m.CreatedAt()
	case medication.FieldUpdatedAt:
		return m.UpdatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *MedicationMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case medication.FieldName:
		return m.OldName(ctx)
	case medication.FieldEffects:
		return m.OldEffects(ctx)
	case medication.FieldExpiredDate:
		return m.OldExpiredDate(ctx)
	case medication.FieldQuantity:
		return m.OldQuantity(ctx)
	case medication.FieldPrice:
		return m.OldPrice(ctx)
	case medication.FieldCreatedBy:
		return m.OldCreatedBy(ctx)
	case medication.FieldUpdatedBy:
		return m.OldUpdatedBy(ctx)
	case medication.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case medication.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown Medication field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *MedicationMutation) SetField(name string, value ent.Value) error {
	switch name {
	case medication.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case medication.FieldEffects:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEffects(v)
		return nil
	case medication.FieldExpiredDate:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetExpiredDate(v)
		return nil
	case medication.FieldQuantity:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetQuantity(v)
		return nil
	case medication.FieldPrice:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPrice(v)
		return nil
	case medication.FieldCreatedBy:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedBy(v)
		return nil
	case medication.FieldUpdatedBy:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedBy(v)
		return nil
	case medication.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case medication.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown Medication field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *MedicationMutation) AddedFields() []string {
	var fields []string
	if m.addquantity != nil {
		fields = append(fields, medication.FieldQuantity)
	}
	if m.addprice != nil {
		fields = append(fields, medication.FieldPrice)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *MedicationMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case medication.FieldQuantity:
		return m.AddedQuantity()
	case medication.FieldPrice:
		return m.AddedPrice()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *MedicationMutation) AddField(name string, value ent.Value) error {
	switch name {
	case medication.FieldQuantity:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddQuantity(v)
		return nil
	case medication.FieldPrice:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddPrice(v)
		return nil
	}
	return fmt.Errorf("unknown Medication numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *MedicationMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *MedicationMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *MedicationMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Medication nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *MedicationMutation) ResetField(name string) error {
	switch name {
	case medication.FieldName:
		m.ResetName()
		return nil
	case medication.FieldEffects:
		m.ResetEffects()
		return nil
	case medication.FieldExpiredDate:
		m.ResetExpiredDate()
		return nil
	case medication.FieldQuantity:
		m.ResetQuantity()
		return nil
	case medication.FieldPrice:
		m.ResetPrice()
		return nil
	case medication.FieldCreatedBy:
		m.ResetCreatedBy()
		return nil
	case medication.FieldUpdatedBy:
		m.ResetUpdatedBy()
		return nil
	case medication.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case medication.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	}
	return fmt.Errorf("unknown Medication field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *MedicationMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.prescription_medication != nil {
		edges = append(edges, medication.EdgePrescriptionMedication)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *MedicationMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case medication.EdgePrescriptionMedication:
		ids := make([]ent.Value, 0, len(m.prescription_medication))
		for id := range m.prescription_medication {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *MedicationMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	if m.removedprescription_medication != nil {
		edges = append(edges, medication.EdgePrescriptionMedication)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *MedicationMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case medication.EdgePrescriptionMedication:
		ids := make([]ent.Value, 0, len(m.removedprescription_medication))
		for id := range m.removedprescription_medication {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *MedicationMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedprescription_medication {
		edges = append(edges, medication.EdgePrescriptionMedication)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *MedicationMutation) EdgeCleared(name string) bool {
	switch name {
	case medication.EdgePrescriptionMedication:
		return m.clearedprescription_medication
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *MedicationMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown Medication unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *MedicationMutation) ResetEdge(name string) error {
	switch name {
	case medication.EdgePrescriptionMedication:
		m.ResetPrescriptionMedication()
		return nil
	}
	return fmt.Errorf("unknown Medication edge %s", name)
}

// PatientMutation represents an operation that mutates the Patient nodes in the graph.
type PatientMutation struct {
	config
	op                     Op
	typ                    string
	id                     *uuid.UUID
	phone                  *string
	first_name             *string
	last_name              *string
	gender                 *int32
	addgender              *int32
	address                *string
	date_of_birth          *time.Time
	created_at             *time.Time
	updated_at             *time.Time
	created_by             *uuid.UUID
	updated_by             *uuid.UUID
	clearedFields          map[string]struct{}
	medical_history        map[uuid.UUID]struct{}
	removedmedical_history map[uuid.UUID]struct{}
	clearedmedical_history bool
	done                   bool
	oldValue               func(context.Context) (*Patient, error)
	predicates             []predicate.Patient
}

var _ ent.Mutation = (*PatientMutation)(nil)

// patientOption allows management of the mutation configuration using functional options.
type patientOption func(*PatientMutation)

// newPatientMutation creates new mutation for the Patient entity.
func newPatientMutation(c config, op Op, opts ...patientOption) *PatientMutation {
	m := &PatientMutation{
		config:        c,
		op:            op,
		typ:           TypePatient,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withPatientID sets the ID field of the mutation.
func withPatientID(id uuid.UUID) patientOption {
	return func(m *PatientMutation) {
		var (
			err   error
			once  sync.Once
			value *Patient
		)
		m.oldValue = func(ctx context.Context) (*Patient, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Patient.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withPatient sets the old Patient of the mutation.
func withPatient(node *Patient) patientOption {
	return func(m *PatientMutation) {
		m.oldValue = func(context.Context) (*Patient, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m PatientMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m PatientMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Patient entities.
func (m *PatientMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *PatientMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *PatientMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Patient.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetPhone sets the "phone" field.
func (m *PatientMutation) SetPhone(s string) {
	m.phone = &s
}

// Phone returns the value of the "phone" field in the mutation.
func (m *PatientMutation) Phone() (r string, exists bool) {
	v := m.phone
	if v == nil {
		return
	}
	return *v, true
}

// OldPhone returns the old "phone" field's value of the Patient entity.
// If the Patient object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PatientMutation) OldPhone(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPhone is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPhone requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPhone: %w", err)
	}
	return oldValue.Phone, nil
}

// ResetPhone resets all changes to the "phone" field.
func (m *PatientMutation) ResetPhone() {
	m.phone = nil
}

// SetFirstName sets the "first_name" field.
func (m *PatientMutation) SetFirstName(s string) {
	m.first_name = &s
}

// FirstName returns the value of the "first_name" field in the mutation.
func (m *PatientMutation) FirstName() (r string, exists bool) {
	v := m.first_name
	if v == nil {
		return
	}
	return *v, true
}

// OldFirstName returns the old "first_name" field's value of the Patient entity.
// If the Patient object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PatientMutation) OldFirstName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFirstName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFirstName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFirstName: %w", err)
	}
	return oldValue.FirstName, nil
}

// ResetFirstName resets all changes to the "first_name" field.
func (m *PatientMutation) ResetFirstName() {
	m.first_name = nil
}

// SetLastName sets the "last_name" field.
func (m *PatientMutation) SetLastName(s string) {
	m.last_name = &s
}

// LastName returns the value of the "last_name" field in the mutation.
func (m *PatientMutation) LastName() (r string, exists bool) {
	v := m.last_name
	if v == nil {
		return
	}
	return *v, true
}

// OldLastName returns the old "last_name" field's value of the Patient entity.
// If the Patient object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PatientMutation) OldLastName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLastName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLastName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLastName: %w", err)
	}
	return oldValue.LastName, nil
}

// ResetLastName resets all changes to the "last_name" field.
func (m *PatientMutation) ResetLastName() {
	m.last_name = nil
}

// SetGender sets the "gender" field.
func (m *PatientMutation) SetGender(i int32) {
	m.gender = &i
	m.addgender = nil
}

// Gender returns the value of the "gender" field in the mutation.
func (m *PatientMutation) Gender() (r int32, exists bool) {
	v := m.gender
	if v == nil {
		return
	}
	return *v, true
}

// OldGender returns the old "gender" field's value of the Patient entity.
// If the Patient object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PatientMutation) OldGender(ctx context.Context) (v int32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldGender is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldGender requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldGender: %w", err)
	}
	return oldValue.Gender, nil
}

// AddGender adds i to the "gender" field.
func (m *PatientMutation) AddGender(i int32) {
	if m.addgender != nil {
		*m.addgender += i
	} else {
		m.addgender = &i
	}
}

// AddedGender returns the value that was added to the "gender" field in this mutation.
func (m *PatientMutation) AddedGender() (r int32, exists bool) {
	v := m.addgender
	if v == nil {
		return
	}
	return *v, true
}

// ResetGender resets all changes to the "gender" field.
func (m *PatientMutation) ResetGender() {
	m.gender = nil
	m.addgender = nil
}

// SetAddress sets the "address" field.
func (m *PatientMutation) SetAddress(s string) {
	m.address = &s
}

// Address returns the value of the "address" field in the mutation.
func (m *PatientMutation) Address() (r string, exists bool) {
	v := m.address
	if v == nil {
		return
	}
	return *v, true
}

// OldAddress returns the old "address" field's value of the Patient entity.
// If the Patient object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PatientMutation) OldAddress(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAddress is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAddress requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAddress: %w", err)
	}
	return oldValue.Address, nil
}

// ResetAddress resets all changes to the "address" field.
func (m *PatientMutation) ResetAddress() {
	m.address = nil
}

// SetDateOfBirth sets the "date_of_birth" field.
func (m *PatientMutation) SetDateOfBirth(t time.Time) {
	m.date_of_birth = &t
}

// DateOfBirth returns the value of the "date_of_birth" field in the mutation.
func (m *PatientMutation) DateOfBirth() (r time.Time, exists bool) {
	v := m.date_of_birth
	if v == nil {
		return
	}
	return *v, true
}

// OldDateOfBirth returns the old "date_of_birth" field's value of the Patient entity.
// If the Patient object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PatientMutation) OldDateOfBirth(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDateOfBirth is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDateOfBirth requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDateOfBirth: %w", err)
	}
	return oldValue.DateOfBirth, nil
}

// ResetDateOfBirth resets all changes to the "date_of_birth" field.
func (m *PatientMutation) ResetDateOfBirth() {
	m.date_of_birth = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *PatientMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *PatientMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Patient entity.
// If the Patient object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PatientMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *PatientMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *PatientMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *PatientMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Patient entity.
// If the Patient object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PatientMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *PatientMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetCreatedBy sets the "created_by" field.
func (m *PatientMutation) SetCreatedBy(u uuid.UUID) {
	m.created_by = &u
}

// CreatedBy returns the value of the "created_by" field in the mutation.
func (m *PatientMutation) CreatedBy() (r uuid.UUID, exists bool) {
	v := m.created_by
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedBy returns the old "created_by" field's value of the Patient entity.
// If the Patient object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PatientMutation) OldCreatedBy(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedBy: %w", err)
	}
	return oldValue.CreatedBy, nil
}

// ResetCreatedBy resets all changes to the "created_by" field.
func (m *PatientMutation) ResetCreatedBy() {
	m.created_by = nil
}

// SetUpdatedBy sets the "updated_by" field.
func (m *PatientMutation) SetUpdatedBy(u uuid.UUID) {
	m.updated_by = &u
}

// UpdatedBy returns the value of the "updated_by" field in the mutation.
func (m *PatientMutation) UpdatedBy() (r uuid.UUID, exists bool) {
	v := m.updated_by
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedBy returns the old "updated_by" field's value of the Patient entity.
// If the Patient object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PatientMutation) OldUpdatedBy(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedBy: %w", err)
	}
	return oldValue.UpdatedBy, nil
}

// ResetUpdatedBy resets all changes to the "updated_by" field.
func (m *PatientMutation) ResetUpdatedBy() {
	m.updated_by = nil
}

// AddMedicalHistoryIDs adds the "medical_history" edge to the MedicalHistories entity by ids.
func (m *PatientMutation) AddMedicalHistoryIDs(ids ...uuid.UUID) {
	if m.medical_history == nil {
		m.medical_history = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.medical_history[ids[i]] = struct{}{}
	}
}

// ClearMedicalHistory clears the "medical_history" edge to the MedicalHistories entity.
func (m *PatientMutation) ClearMedicalHistory() {
	m.clearedmedical_history = true
}

// MedicalHistoryCleared reports if the "medical_history" edge to the MedicalHistories entity was cleared.
func (m *PatientMutation) MedicalHistoryCleared() bool {
	return m.clearedmedical_history
}

// RemoveMedicalHistoryIDs removes the "medical_history" edge to the MedicalHistories entity by IDs.
func (m *PatientMutation) RemoveMedicalHistoryIDs(ids ...uuid.UUID) {
	if m.removedmedical_history == nil {
		m.removedmedical_history = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.medical_history, ids[i])
		m.removedmedical_history[ids[i]] = struct{}{}
	}
}

// RemovedMedicalHistory returns the removed IDs of the "medical_history" edge to the MedicalHistories entity.
func (m *PatientMutation) RemovedMedicalHistoryIDs() (ids []uuid.UUID) {
	for id := range m.removedmedical_history {
		ids = append(ids, id)
	}
	return
}

// MedicalHistoryIDs returns the "medical_history" edge IDs in the mutation.
func (m *PatientMutation) MedicalHistoryIDs() (ids []uuid.UUID) {
	for id := range m.medical_history {
		ids = append(ids, id)
	}
	return
}

// ResetMedicalHistory resets all changes to the "medical_history" edge.
func (m *PatientMutation) ResetMedicalHistory() {
	m.medical_history = nil
	m.clearedmedical_history = false
	m.removedmedical_history = nil
}

// Where appends a list predicates to the PatientMutation builder.
func (m *PatientMutation) Where(ps ...predicate.Patient) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the PatientMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *PatientMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Patient, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *PatientMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *PatientMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Patient).
func (m *PatientMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *PatientMutation) Fields() []string {
	fields := make([]string, 0, 10)
	if m.phone != nil {
		fields = append(fields, patient.FieldPhone)
	}
	if m.first_name != nil {
		fields = append(fields, patient.FieldFirstName)
	}
	if m.last_name != nil {
		fields = append(fields, patient.FieldLastName)
	}
	if m.gender != nil {
		fields = append(fields, patient.FieldGender)
	}
	if m.address != nil {
		fields = append(fields, patient.FieldAddress)
	}
	if m.date_of_birth != nil {
		fields = append(fields, patient.FieldDateOfBirth)
	}
	if m.created_at != nil {
		fields = append(fields, patient.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, patient.FieldUpdatedAt)
	}
	if m.created_by != nil {
		fields = append(fields, patient.FieldCreatedBy)
	}
	if m.updated_by != nil {
		fields = append(fields, patient.FieldUpdatedBy)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *PatientMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case patient.FieldPhone:
		return m.Phone()
	case patient.FieldFirstName:
		return m.FirstName()
	case patient.FieldLastName:
		return m.LastName()
	case patient.FieldGender:
		return m.Gender()
	case patient.FieldAddress:
		return m.Address()
	case patient.FieldDateOfBirth:
		return m.DateOfBirth()
	case patient.FieldCreatedAt:
		return m.CreatedAt()
	case patient.FieldUpdatedAt:
		return m.UpdatedAt()
	case patient.FieldCreatedBy:
		return m.CreatedBy()
	case patient.FieldUpdatedBy:
		return m.UpdatedBy()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *PatientMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case patient.FieldPhone:
		return m.OldPhone(ctx)
	case patient.FieldFirstName:
		return m.OldFirstName(ctx)
	case patient.FieldLastName:
		return m.OldLastName(ctx)
	case patient.FieldGender:
		return m.OldGender(ctx)
	case patient.FieldAddress:
		return m.OldAddress(ctx)
	case patient.FieldDateOfBirth:
		return m.OldDateOfBirth(ctx)
	case patient.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case patient.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case patient.FieldCreatedBy:
		return m.OldCreatedBy(ctx)
	case patient.FieldUpdatedBy:
		return m.OldUpdatedBy(ctx)
	}
	return nil, fmt.Errorf("unknown Patient field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *PatientMutation) SetField(name string, value ent.Value) error {
	switch name {
	case patient.FieldPhone:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPhone(v)
		return nil
	case patient.FieldFirstName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFirstName(v)
		return nil
	case patient.FieldLastName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLastName(v)
		return nil
	case patient.FieldGender:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetGender(v)
		return nil
	case patient.FieldAddress:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAddress(v)
		return nil
	case patient.FieldDateOfBirth:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDateOfBirth(v)
		return nil
	case patient.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case patient.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case patient.FieldCreatedBy:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedBy(v)
		return nil
	case patient.FieldUpdatedBy:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedBy(v)
		return nil
	}
	return fmt.Errorf("unknown Patient field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *PatientMutation) AddedFields() []string {
	var fields []string
	if m.addgender != nil {
		fields = append(fields, patient.FieldGender)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *PatientMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case patient.FieldGender:
		return m.AddedGender()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *PatientMutation) AddField(name string, value ent.Value) error {
	switch name {
	case patient.FieldGender:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddGender(v)
		return nil
	}
	return fmt.Errorf("unknown Patient numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *PatientMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *PatientMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *PatientMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Patient nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *PatientMutation) ResetField(name string) error {
	switch name {
	case patient.FieldPhone:
		m.ResetPhone()
		return nil
	case patient.FieldFirstName:
		m.ResetFirstName()
		return nil
	case patient.FieldLastName:
		m.ResetLastName()
		return nil
	case patient.FieldGender:
		m.ResetGender()
		return nil
	case patient.FieldAddress:
		m.ResetAddress()
		return nil
	case patient.FieldDateOfBirth:
		m.ResetDateOfBirth()
		return nil
	case patient.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case patient.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case patient.FieldCreatedBy:
		m.ResetCreatedBy()
		return nil
	case patient.FieldUpdatedBy:
		m.ResetUpdatedBy()
		return nil
	}
	return fmt.Errorf("unknown Patient field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *PatientMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.medical_history != nil {
		edges = append(edges, patient.EdgeMedicalHistory)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *PatientMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case patient.EdgeMedicalHistory:
		ids := make([]ent.Value, 0, len(m.medical_history))
		for id := range m.medical_history {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *PatientMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	if m.removedmedical_history != nil {
		edges = append(edges, patient.EdgeMedicalHistory)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *PatientMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case patient.EdgeMedicalHistory:
		ids := make([]ent.Value, 0, len(m.removedmedical_history))
		for id := range m.removedmedical_history {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *PatientMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedmedical_history {
		edges = append(edges, patient.EdgeMedicalHistory)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *PatientMutation) EdgeCleared(name string) bool {
	switch name {
	case patient.EdgeMedicalHistory:
		return m.clearedmedical_history
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *PatientMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown Patient unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *PatientMutation) ResetEdge(name string) error {
	switch name {
	case patient.EdgeMedicalHistory:
		m.ResetMedicalHistory()
		return nil
	}
	return fmt.Errorf("unknown Patient edge %s", name)
}

// PrescriptionMedicationMutation represents an operation that mutates the PrescriptionMedication nodes in the graph.
type PrescriptionMedicationMutation struct {
	config
	op                          Op
	typ                         string
	id                          *uuid.UUID
	quantity                    *int64
	addquantity                 *int64
	clearedFields               map[string]struct{}
	medical_prescription        *uuid.UUID
	clearedmedical_prescription bool
	medication                  *uuid.UUID
	clearedmedication           bool
	done                        bool
	oldValue                    func(context.Context) (*PrescriptionMedication, error)
	predicates                  []predicate.PrescriptionMedication
}

var _ ent.Mutation = (*PrescriptionMedicationMutation)(nil)

// prescriptionmedicationOption allows management of the mutation configuration using functional options.
type prescriptionmedicationOption func(*PrescriptionMedicationMutation)

// newPrescriptionMedicationMutation creates new mutation for the PrescriptionMedication entity.
func newPrescriptionMedicationMutation(c config, op Op, opts ...prescriptionmedicationOption) *PrescriptionMedicationMutation {
	m := &PrescriptionMedicationMutation{
		config:        c,
		op:            op,
		typ:           TypePrescriptionMedication,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withPrescriptionMedicationID sets the ID field of the mutation.
func withPrescriptionMedicationID(id uuid.UUID) prescriptionmedicationOption {
	return func(m *PrescriptionMedicationMutation) {
		var (
			err   error
			once  sync.Once
			value *PrescriptionMedication
		)
		m.oldValue = func(ctx context.Context) (*PrescriptionMedication, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().PrescriptionMedication.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withPrescriptionMedication sets the old PrescriptionMedication of the mutation.
func withPrescriptionMedication(node *PrescriptionMedication) prescriptionmedicationOption {
	return func(m *PrescriptionMedicationMutation) {
		m.oldValue = func(context.Context) (*PrescriptionMedication, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m PrescriptionMedicationMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m PrescriptionMedicationMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of PrescriptionMedication entities.
func (m *PrescriptionMedicationMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *PrescriptionMedicationMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *PrescriptionMedicationMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().PrescriptionMedication.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetPrescriptionID sets the "prescription_id" field.
func (m *PrescriptionMedicationMutation) SetPrescriptionID(u uuid.UUID) {
	m.medical_prescription = &u
}

// PrescriptionID returns the value of the "prescription_id" field in the mutation.
func (m *PrescriptionMedicationMutation) PrescriptionID() (r uuid.UUID, exists bool) {
	v := m.medical_prescription
	if v == nil {
		return
	}
	return *v, true
}

// OldPrescriptionID returns the old "prescription_id" field's value of the PrescriptionMedication entity.
// If the PrescriptionMedication object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PrescriptionMedicationMutation) OldPrescriptionID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPrescriptionID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPrescriptionID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPrescriptionID: %w", err)
	}
	return oldValue.PrescriptionID, nil
}

// ResetPrescriptionID resets all changes to the "prescription_id" field.
func (m *PrescriptionMedicationMutation) ResetPrescriptionID() {
	m.medical_prescription = nil
}

// SetMedicationID sets the "medication_id" field.
func (m *PrescriptionMedicationMutation) SetMedicationID(u uuid.UUID) {
	m.medication = &u
}

// MedicationID returns the value of the "medication_id" field in the mutation.
func (m *PrescriptionMedicationMutation) MedicationID() (r uuid.UUID, exists bool) {
	v := m.medication
	if v == nil {
		return
	}
	return *v, true
}

// OldMedicationID returns the old "medication_id" field's value of the PrescriptionMedication entity.
// If the PrescriptionMedication object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PrescriptionMedicationMutation) OldMedicationID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMedicationID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMedicationID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMedicationID: %w", err)
	}
	return oldValue.MedicationID, nil
}

// ResetMedicationID resets all changes to the "medication_id" field.
func (m *PrescriptionMedicationMutation) ResetMedicationID() {
	m.medication = nil
}

// SetQuantity sets the "quantity" field.
func (m *PrescriptionMedicationMutation) SetQuantity(i int64) {
	m.quantity = &i
	m.addquantity = nil
}

// Quantity returns the value of the "quantity" field in the mutation.
func (m *PrescriptionMedicationMutation) Quantity() (r int64, exists bool) {
	v := m.quantity
	if v == nil {
		return
	}
	return *v, true
}

// OldQuantity returns the old "quantity" field's value of the PrescriptionMedication entity.
// If the PrescriptionMedication object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PrescriptionMedicationMutation) OldQuantity(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldQuantity is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldQuantity requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldQuantity: %w", err)
	}
	return oldValue.Quantity, nil
}

// AddQuantity adds i to the "quantity" field.
func (m *PrescriptionMedicationMutation) AddQuantity(i int64) {
	if m.addquantity != nil {
		*m.addquantity += i
	} else {
		m.addquantity = &i
	}
}

// AddedQuantity returns the value that was added to the "quantity" field in this mutation.
func (m *PrescriptionMedicationMutation) AddedQuantity() (r int64, exists bool) {
	v := m.addquantity
	if v == nil {
		return
	}
	return *v, true
}

// ResetQuantity resets all changes to the "quantity" field.
func (m *PrescriptionMedicationMutation) ResetQuantity() {
	m.quantity = nil
	m.addquantity = nil
}

// SetMedicalPrescriptionID sets the "medical_prescription" edge to the MedicalPrescription entity by id.
func (m *PrescriptionMedicationMutation) SetMedicalPrescriptionID(id uuid.UUID) {
	m.medical_prescription = &id
}

// ClearMedicalPrescription clears the "medical_prescription" edge to the MedicalPrescription entity.
func (m *PrescriptionMedicationMutation) ClearMedicalPrescription() {
	m.clearedmedical_prescription = true
	m.clearedFields[prescriptionmedication.FieldPrescriptionID] = struct{}{}
}

// MedicalPrescriptionCleared reports if the "medical_prescription" edge to the MedicalPrescription entity was cleared.
func (m *PrescriptionMedicationMutation) MedicalPrescriptionCleared() bool {
	return m.clearedmedical_prescription
}

// MedicalPrescriptionID returns the "medical_prescription" edge ID in the mutation.
func (m *PrescriptionMedicationMutation) MedicalPrescriptionID() (id uuid.UUID, exists bool) {
	if m.medical_prescription != nil {
		return *m.medical_prescription, true
	}
	return
}

// MedicalPrescriptionIDs returns the "medical_prescription" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// MedicalPrescriptionID instead. It exists only for internal usage by the builders.
func (m *PrescriptionMedicationMutation) MedicalPrescriptionIDs() (ids []uuid.UUID) {
	if id := m.medical_prescription; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetMedicalPrescription resets all changes to the "medical_prescription" edge.
func (m *PrescriptionMedicationMutation) ResetMedicalPrescription() {
	m.medical_prescription = nil
	m.clearedmedical_prescription = false
}

// ClearMedication clears the "medication" edge to the Medication entity.
func (m *PrescriptionMedicationMutation) ClearMedication() {
	m.clearedmedication = true
	m.clearedFields[prescriptionmedication.FieldMedicationID] = struct{}{}
}

// MedicationCleared reports if the "medication" edge to the Medication entity was cleared.
func (m *PrescriptionMedicationMutation) MedicationCleared() bool {
	return m.clearedmedication
}

// MedicationIDs returns the "medication" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// MedicationID instead. It exists only for internal usage by the builders.
func (m *PrescriptionMedicationMutation) MedicationIDs() (ids []uuid.UUID) {
	if id := m.medication; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetMedication resets all changes to the "medication" edge.
func (m *PrescriptionMedicationMutation) ResetMedication() {
	m.medication = nil
	m.clearedmedication = false
}

// Where appends a list predicates to the PrescriptionMedicationMutation builder.
func (m *PrescriptionMedicationMutation) Where(ps ...predicate.PrescriptionMedication) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the PrescriptionMedicationMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *PrescriptionMedicationMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.PrescriptionMedication, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *PrescriptionMedicationMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *PrescriptionMedicationMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (PrescriptionMedication).
func (m *PrescriptionMedicationMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *PrescriptionMedicationMutation) Fields() []string {
	fields := make([]string, 0, 3)
	if m.medical_prescription != nil {
		fields = append(fields, prescriptionmedication.FieldPrescriptionID)
	}
	if m.medication != nil {
		fields = append(fields, prescriptionmedication.FieldMedicationID)
	}
	if m.quantity != nil {
		fields = append(fields, prescriptionmedication.FieldQuantity)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *PrescriptionMedicationMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case prescriptionmedication.FieldPrescriptionID:
		return m.PrescriptionID()
	case prescriptionmedication.FieldMedicationID:
		return m.MedicationID()
	case prescriptionmedication.FieldQuantity:
		return m.Quantity()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *PrescriptionMedicationMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case prescriptionmedication.FieldPrescriptionID:
		return m.OldPrescriptionID(ctx)
	case prescriptionmedication.FieldMedicationID:
		return m.OldMedicationID(ctx)
	case prescriptionmedication.FieldQuantity:
		return m.OldQuantity(ctx)
	}
	return nil, fmt.Errorf("unknown PrescriptionMedication field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *PrescriptionMedicationMutation) SetField(name string, value ent.Value) error {
	switch name {
	case prescriptionmedication.FieldPrescriptionID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPrescriptionID(v)
		return nil
	case prescriptionmedication.FieldMedicationID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMedicationID(v)
		return nil
	case prescriptionmedication.FieldQuantity:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetQuantity(v)
		return nil
	}
	return fmt.Errorf("unknown PrescriptionMedication field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *PrescriptionMedicationMutation) AddedFields() []string {
	var fields []string
	if m.addquantity != nil {
		fields = append(fields, prescriptionmedication.FieldQuantity)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *PrescriptionMedicationMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case prescriptionmedication.FieldQuantity:
		return m.AddedQuantity()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *PrescriptionMedicationMutation) AddField(name string, value ent.Value) error {
	switch name {
	case prescriptionmedication.FieldQuantity:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddQuantity(v)
		return nil
	}
	return fmt.Errorf("unknown PrescriptionMedication numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *PrescriptionMedicationMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *PrescriptionMedicationMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *PrescriptionMedicationMutation) ClearField(name string) error {
	return fmt.Errorf("unknown PrescriptionMedication nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *PrescriptionMedicationMutation) ResetField(name string) error {
	switch name {
	case prescriptionmedication.FieldPrescriptionID:
		m.ResetPrescriptionID()
		return nil
	case prescriptionmedication.FieldMedicationID:
		m.ResetMedicationID()
		return nil
	case prescriptionmedication.FieldQuantity:
		m.ResetQuantity()
		return nil
	}
	return fmt.Errorf("unknown PrescriptionMedication field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *PrescriptionMedicationMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.medical_prescription != nil {
		edges = append(edges, prescriptionmedication.EdgeMedicalPrescription)
	}
	if m.medication != nil {
		edges = append(edges, prescriptionmedication.EdgeMedication)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *PrescriptionMedicationMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case prescriptionmedication.EdgeMedicalPrescription:
		if id := m.medical_prescription; id != nil {
			return []ent.Value{*id}
		}
	case prescriptionmedication.EdgeMedication:
		if id := m.medication; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *PrescriptionMedicationMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *PrescriptionMedicationMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *PrescriptionMedicationMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedmedical_prescription {
		edges = append(edges, prescriptionmedication.EdgeMedicalPrescription)
	}
	if m.clearedmedication {
		edges = append(edges, prescriptionmedication.EdgeMedication)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *PrescriptionMedicationMutation) EdgeCleared(name string) bool {
	switch name {
	case prescriptionmedication.EdgeMedicalPrescription:
		return m.clearedmedical_prescription
	case prescriptionmedication.EdgeMedication:
		return m.clearedmedication
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *PrescriptionMedicationMutation) ClearEdge(name string) error {
	switch name {
	case prescriptionmedication.EdgeMedicalPrescription:
		m.ClearMedicalPrescription()
		return nil
	case prescriptionmedication.EdgeMedication:
		m.ClearMedication()
		return nil
	}
	return fmt.Errorf("unknown PrescriptionMedication unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *PrescriptionMedicationMutation) ResetEdge(name string) error {
	switch name {
	case prescriptionmedication.EdgeMedicalPrescription:
		m.ResetMedicalPrescription()
		return nil
	case prescriptionmedication.EdgeMedication:
		m.ResetMedication()
		return nil
	}
	return fmt.Errorf("unknown PrescriptionMedication edge %s", name)
}
